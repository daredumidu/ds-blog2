<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Policy Tool</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self';">
    <!-- Load jsPDF from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
    // Ensure jsPDF is available globally
    window.jsPDF = window.jspdf?.jsPDF || window.jsPDF;
    </script>
    <link rel="stylesheet" href="v2-design.css">
</head>
<body>

<!-- Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-content">
            <!-- G20 Logo on left -->
            <div class="nav-logo">
                <img src="assets/icons/g20-logo.png" alt="G20 Logo" class="g20-logo-img">
            </div>
            
            <!-- Navigation Menu -->
            <div class="nav-menu">
                <div class="nav-links">
                    <div class="nav-item dropdown">
                        <a href="#" class="nav-link">Home <span class="dropdown-arrow">▼</span></a>
                    </div>
                    <!-- <div class="nav-item dropdown">
                        <a href="#" class="nav-link">Policies <span class="dropdown-arrow">▼</span></a>
                    </div> -->
                    <div class="nav-item dropdown">
                        <a href="#" class="nav-link">Case Studies <span class="dropdown-arrow">▼</span></a>
                    </div>
                    <div class="nav-item dropdown">
                        <a href="#" class="nav-link">Experts <span class="dropdown-arrow">▼</span></a>
                    </div>
                </div>
                
                <!-- Language Selector and Search -->
                <div class="nav-tools">
                    <div class="language-selector">
                        <select class="language-select">
                            <option value="en">English</option>
                        </select>
                    </div>
                    <button class="search-btn" aria-label="Search">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Header Banner -->
    <div class="header-banner">
        <div class="banner-content">
            <!-- Title text positioned on the left -->
            <div class="banner-title">
                <!-- <h1>G20 Technology Policy<br />Assistance Facility</h1> -->
            </div>
        </div>
    </div>
    

    <div class="container">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Enhanced Navigation -->
            <div class="section">
                <!-- Search & Filter - Always visible -->
                <div class="search-filter-section" id="searchFilterSection">
                    <div class="search-filter-row">
                        <div class="search-container">
                            <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <circle cx="11" cy="11" r="8"></circle>
                                <path d="m21 21-4.35-4.35"></path>
                            </svg>
                            <input type="text" class="search-input" id="policySearchInput" placeholder="Search policy initiatives...">
                        </div>
                        <div class="keyword-filters-container">
                            <select class="keyword-dropdown" id="keywordDropdown">
                                <option value="">Filter by keyword...</option>
                            </select>

                            <button class="clear-filters-btn" id="clearFiltersBtn" style="display: none;">Clear Filters</button>

                            <!-- Inline keyword chips -->
                            <div class="active-keywords-inline" style="position: relative;">
                                <div class="visible-keywords" id="visibleKeywords">
                                    <!-- Keywords will be inserted here -->
                                </div>
                                <div class="keywords-overflow" id="keywordsOverflow" style="display: none;">
                                    +2 more
                                </div>
                                
                                <!-- Tooltip for overflow -->
                                <div class="keywords-tooltip" id="keywordsTooltip">
                                    <div class="tooltip-keywords" id="tooltipKeywords">
                                        <!-- All keywords shown here on hover -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <h2>Select Policy Area</h2>
                <div class="dimensions-container" id="dimensionGrid">
                    <!-- Policy Areas will be populated by JavaScript -->
                </div>
                
                <!-- Progressive Disclosure: Phases -->
                <div class="phases-section" id="phasesSection">
                    <!-- <h2>Implementation Phase</h2> -->
                    <div class="phases-container" id="phaseGrid">
                        <!-- Phases will be populated by JavaScript -->
                    </div>
                </div>
            </div>


            <!-- Two-Column Policy Layout -->
            <div class="section hidden" id="policySection">
                <div class="policy-container" id="policyContainer">
                    <!-- Left Column: Policy List -->
                    <div class="policy-list-column">
                        <div class="policy-list-column-content">
                            <div class="policy-list-header" id="policyListTitle">
                                Select a dimension and phase
                            </div>
                            <div class="policy-list" id="policyList">
                                <div class="empty-state">
                                    <div class="empty-state-icon">📋</div>
                                    <div class="empty-state-text">
                                        Choose a policy area and phase to view available initiatives
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: Initiative Details -->
                    <div class="policy-details-column" id="policyDetailsColumn">
                        <!-- Collapse/Expand Toggle Button -->
                        <button class="policy-list-toggle" id="policyListToggle" aria-label="Back to policy list">
                            <svg class="policy-list-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                            </svg>
                            Back to List
                        </button>
                        
                        <div class="details-header">
                            <div class="details-title">Policy Initiative Details</div>
                            <button class="btn-select hidden" id="selectPolicyBtn" aria-describedby="select-help">
                                Add policy initiative to your plan
                            </button>
                        </div>
                        <div class="details-content" id="policyDetailsContent">
                            <div class="empty-state">
                                <div class="empty-state-icon">📄</div>
                                <div class="empty-state-text">
                                    Select a policy initiative from the list to view its details
                                </div>
                            </div>
                        </div>
                        <span id="select-help" class="sr-only">Select this policy initiative to add it to your implementation plan</span>
                    </div>
                </div>
            </div>

            <!-- Selected Policy Initiatives Section -->
            <div class="section hidden" id="selectedPoliciesSection">
                <h2>Selected Policy Initiatives</h2>
                <div class="selected-policies-container">
                    <div class="selected-policies-header">
                        <span class="selected-count" id="selectedPoliciesCount">0 policy initiatives selected</span>
                        <button class="clear-all-btn" id="clearAllBtn">Clear All</button>
                    </div>
                    <div class="selected-policies-list" id="selectedPoliciesList">
                        <div class="empty-state">
                            <div class="empty-state-icon">📋</div>
                            <div class="empty-state-text">
                                No policy initiatives selected yet. Select initiatives to see them here
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Smart Suggestions -->
                <!-- Smart suggestions will be populated by JavaScript -->
            <!-- </div> -->

            <!-- Instructions with integrated export -->
            <div class="section">
                <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">How to use</h3>
                <div style="font-size: 0.8rem; color: var(--color-gray-600); line-height: 1.5; margin-bottom: 1rem;">
                    Search for policy initiatives or browse by policy area and phase <br> Select policy initiatives to read more <br> Export your policy plan
                </div>
                
                <button class="export-btn export-pdf" onclick="exportToPDF()" style="width: 100%; justify-content: center;">
                    Export Your Policy Plan as a PDF
                </button>
            </div>
            
            <!-- Matrix with Bars -->
            <div class="selection-matrix-container">
                <div class="matrix-title">Policy Plan Dashboard</div>
                <div class="matrix-subtitle">Track your selected policy initiatives across areas and phases <br>
                    
                <!-- </div> -->
                
                <!-- Matrix Guidance -->
                <!-- <div class="matrix-guidance"> -->
                    <!-- Click any bar to explore that policy initiative.  </br> Bars show your selections and related recommendations. -->
                </div>
                
                <!-- Matrix Legend -->
                <div class="matrix-legend">
                    <div class="legend-item">
                        <div class="legend-bar selected"></div>
                        <span>Selected</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-bar related"></div>
                        <span>Related</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-bar viewing"></div>
                        <span>Viewing</span>
                    </div>
                </div>
                
                <div class="selection-coordinate-system">
                    <div class="coordinate-grid" style="position: relative;">
                        <div class="y-axis-labels">
                            <div class="y-axis-label">Monitoring & Evaluation</div>
                            <div class="y-axis-label">Implementation</div>
                            <div class="y-axis-label">Design</div>
                            <div class="y-axis-label">Analysis</div>
                        </div>
                        
                        <div class="main-grid" id="selectionGrid">
                            <!-- Grid cells will be generated by JavaScript -->
                        </div>
                        
                        <div></div> <!-- Empty cell for spacing -->
                        
                        <div class="x-axis-labels">
                            <div class="x-axis-label">Infrastructure</div>
                            <div class="x-axis-label">Legislation</div>
                            <div class="x-axis-label">Sustainability</div>
                            <div class="x-axis-label">Economy</div>
                            <div class="x-axis-label">Research</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Current Selection
            <div class="current-selection" id="currentSelection">
                <div class="selection-title">Current Selection</div>
                <div class="selection-info" id="selectionInfo">
                    Select a dimension to begin
                </div>
            </div> -->

            <!-- Expert Profiles -->
            <div class="experts-section" id="expertsSection">
                <div class="experts-title">Relevant Experts</div>
                <div class="experts-grid" id="expertsGrid">
                    <div class="loading-message">Loading experts...</div>
                </div>
            </div>


        </div>
    </div>
    <script>
        let policyData = {};
        let expertsData = [];   
        'use strict';
        
        (function() {
            // Global variables for data

            const CONFIG = {
                DIMENSIONS: [
                    { 
                        id: 'Enabling Infrastructure', 
                        color: 'rgb(22, 102, 106)',
                        short: 'Enabling Infrastructure',
                        coloredIcon: 'assets/icons/new-icons/blue-infra-01.svg',
                        whiteIcon: 'assets/icons/new-icons/blue-infra-01.svg'
                    },
                    { 
                        id: 'Legislation & Policy', 
                        color: '#cb9b3d',  
                        short: 'Legislation & Policy',
                        coloredIcon: 'assets/icons/new-icons/yellow-legislation-01.svg',
                        whiteIcon: 'assets/icons/new-icons/yellow-legislation-01.svg'
                    },
                    { 
                        id: 'Sustainability & Society', 
                        color: '#5f0085',  
                        short: 'Sustainability & Society',
                        coloredIcon: 'assets/icons/new-icons/purple-sustainability-01.svg',
                        whiteIcon: 'assets/icons/new-icons/purple-sustainability-01.svg'
                    },
                    { 
                        id: 'Economy & Innovation', 
                        color: '#8b2f30',
                        short: 'Economic Measures and Innovation',
                        coloredIcon: 'assets/icons/new-icons/red-economic-01.svg',
                        whiteIcon: 'assets/icons/new-icons/red-economic-01.svg'
                    },
                    { 
                        id: 'Research & Education', 
                        color: '#005b3a', 
                        short: 'Research, Education & Capacity Building',
                        coloredIcon: 'assets/icons/new-icons/green-research-01.svg',
                        whiteIcon: 'assets/icons/new-icons/green-research-01.svg'
                    }
                ],
                PHASES: [
                    { id: 'Analysis', short: 'Analysis' },
                    { id: 'Design', short: 'Design' },
                    { id: 'Implementation', short: 'Implementation' },
                    { id: 'Monitoring and Evaluation', short: 'Monitoring & Evaluation' }
                ]
            };


            // Data loading functions
            async function loadPolicyData() {
                try {
                    const response = await fetch('policy-data.json');
                    if (!response.ok) {
                        throw new Error(`Failed to load policy data: ${response.status}`);
                    }
                    const data = await response.json();

                    // Flatten the structure to match original code expectations
                    const flattenedData = {};
                    const sourceData = data.policyAreas || data;

                    Object.entries(sourceData).forEach(([policyArea, areaData]) => {
                        flattenedData[policyArea] = {};
                        
                        if (areaData.phases) {
                            // New structure with phases wrapper
                            Object.entries(areaData.phases).forEach(([phase, phaseData]) => {
                                flattenedData[policyArea][phase] = {};
                                
                                if (phaseData.policies && Array.isArray(phaseData.policies)) {
                                    // Convert policies array to object keyed by policy ID
                                    phaseData.policies.forEach(policy => {
                                        if (policy.id) {
                                            flattenedData[policyArea][phase][policy.id] = {
                                                policy: policy.title || policy.policy,
                                                details: policy.description || policy.details,
                                                examples: policy.examples || '',
                                                keywords: policy.keywords || []
                                            };
                                        }
                                    });
                                } else {
                                    // Direct object structure
                                    flattenedData[policyArea][phase] = phaseData;
                                }
                            });
                        } else {
                            // Old structure without phases wrapper
                            flattenedData[policyArea] = areaData;
                        }
                    });

                    policyData = flattenedData;
                    console.log('Flattened policyData structure:', Object.keys(policyData));
                    if (policyData['Enabling Infrastructure']) {
                        console.log('Phases in Enabling Infrastructure:', Object.keys(policyData['Enabling Infrastructure']));
                        if (policyData['Enabling Infrastructure']['Analysis']) {
                            console.log('Policies in Analysis:', Object.keys(policyData['Enabling Infrastructure']['Analysis']));
                            const firstPolicyId = Object.keys(policyData['Enabling Infrastructure']['Analysis'])[0];
                            if (firstPolicyId) {
                                console.log('First policy:', firstPolicyId, policyData['Enabling Infrastructure']['Analysis'][firstPolicyId]);
                            }
                        }
                    }
                    console.log('Policy data loaded successfully');
                    return true;
                } catch (error) {
                    console.error('Error loading policy data:', error);
                    // Fallback error message
                    document.body.innerHTML = `
                        <div style="padding: 2rem; text-align: center;">
                            <div class="error-message">
                                Failed to load policy data. Please ensure 'policy-data.json' is available and try refreshing the page.
                            </div>
                        </div>
                    `;
                    return false;
                }
            }

            async function loadExpertsData() {
                try {
                    const response = await fetch('expert-data.json');
                    if (!response.ok) {
                        throw new Error(`Failed to load experts data: ${response.status}`);
                    }
                    const data = await response.json();
                    expertsData = data.experts || data;
                    console.log('Experts data loaded successfully');
                    return true;
                } catch (error) {
                    console.error('Error loading experts data:', error);
                    // Show error in experts section
                    const expertsGrid = document.getElementById('expertsGrid');
                    if (expertsGrid) {
                        expertsGrid.innerHTML = `
                            <div class="error-message">
                                Unable to load expert profiles. Please check that 'experts-data.json' is available.
                            </div>
                        `;
                    }
                    return false;
                }
            }

            // Expert matching and rendering functions
            function getAvatarColor(name) {
                const colors = [
                    '#4F8EDB', '#FFA726', '#AB47BC', '#EF5350', 
                    '#66BB6A', '#FF7043', '#42A5F5', '#9CCC65'
                ];
                const hash = name.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return colors[Math.abs(hash) % colors.length];
            }

            function getInitials(name) {
                return name.split(' ')
                          .map(word => word[0])
                          .join('')
                          .toUpperCase()
                          .slice(0, 2);
            }


            function findRelevantExperts(policyKeywords, limit = 4) {
                if (!policyKeywords || policyKeywords.length === 0) {
                    // Return a sample of experts if no specific keywords
                    return expertsData.slice(0, limit);
                }

                const scoredExperts = expertsData.map(expert => {
                    const expertKeywords = expert.keywords || [];
                    let score = 0;
                    
                    // Calculate keyword overlap
                    policyKeywords.forEach(policyKeyword => {
                        expertKeywords.forEach(expertKeyword => {
                            if (expertKeyword.toLowerCase().includes(policyKeyword.toLowerCase()) ||
                                policyKeyword.toLowerCase().includes(expertKeyword.toLowerCase())) {
                                score += 1;
                            }
                        });
                    });

                    return { ...expert, relevanceScore: score };
                });
                // Sort by relevance score and return top results
                return scoredExperts
                    .filter(expert => expert.relevanceScore > 0)
                    .sort((a, b) => b.relevanceScore - a.relevanceScore)
                    .slice(0, limit);
            }

            function renderExpertCard(expert) {
                const initials = getInitials(expert.name);
                const avatarColor = getAvatarColor(expert.name);
                
                const avatarElement = expert.imageUrl 
                    ? `<img src="${expert.imageUrl}" alt="${expert.name}" class="expert-avatar">`
                    : `<div class="expert-avatar-fallback" style="background-color: ${avatarColor};">${initials}</div>`;
                
                const linkedinElement = expert.linkedin 
                    ? `<a href="${expert.linkedin}" target="_blank" rel="noopener noreferrer" class="expert-linkedin" onclick="event.stopPropagation();">
                         See profile →
                       </a>`
                    : '';
                const expertiseDisplay = expert.expertise ? expert.expertise.slice(0, 3) : [];
                const keywordsDisplay = expert.keywords ? expert.keywords.slice(0, 3) : [];
                
                return `
                    <div class="expert-card" onclick="openExpertProfile('${expert.profileUrl || expert.linkedin || '#'}')" title="Click to view ${expert.name}'s profile">
                        ${avatarElement}
                        <div class="expert-info">
                            <div class="expert-header">
                                <div>
                                    <div class="expert-name">${expert.name}</div>
                                    <div class="expert-title">${expert.title}</div>
                                </div>
                                ${linkedinElement}
                            </div>
                            
                            <div class="expert-details">
                                <div class="expert-detail-row">
                                    <svg class="expert-detail-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"/>
                                    </svg>
                                    <span>${expert.languages.join(', ')}</span>
                                </div>
                                <div class="expert-detail-row">
                                    <svg class="expert-detail-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>${expert.regions.join(', ')}</span>
                                </div>
                            </div>
                            
                            ${keywordsDisplay.length > 0 ? `
                            <div class="expert-expertise">
                                ${keywordsDisplay.map(area => `<span class="expert-expertise-tag">${area}</span>`).join('')}
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            function updateRelevantExperts(selectedPolicy = null) {
                const expertsGrid = document.getElementById('expertsGrid');
                if (!expertsGrid || expertsData.length === 0) return;

                let policyKeywords = [];
                
                // Get keywords from currently selected policy
                if (selectedPolicy && state.selectedPolicyArea && state.selectedPhase) {
                    // Use the current state to get the policy info, not the selectedPolicy parameter
                    const policyInfo = policyData[state.selectedPolicyArea]?.[state.selectedPhase]?.[state.selectedPolicy];
                    if (policyInfo && policyInfo.keywords) {
                        policyKeywords = policyInfo.keywords;
                    }
                }

                // Find relevant experts
                const relevantExperts = findRelevantExperts(policyKeywords, 4);
                
                if (relevantExperts.length > 0) {
                    expertsGrid.innerHTML = relevantExperts.map(expert => renderExpertCard(expert)).join('');
                } else {
                    // Fallback to showing first 4 experts if no matches
                    const fallbackExperts = expertsData.slice(0, 4);
                    expertsGrid.innerHTML = fallbackExperts.map(expert => renderExpertCard(expert)).join('');
                }
            }

            function openExpertProfile(profileUrl) {
                if (profileUrl && profileUrl !== '#') {
                    window.open(profileUrl, '_blank');
                }
            }

            // Make functions available globally
            window.openExpertProfile = openExpertProfile;


            const maxVisibleChips = 3;
            // here was the policy data before

            

            // Application state
            let state = {
                selectedPolicyArea: null,
                selectedPhase: null,
                selectedPolicy: null,
                selectedPolicies: new Set(),
                relatedPolicies: new Set(),
                isLoading: false,
                searchTerm: '',
                activeKeywords: new Set(),
                filteredPolicies: null,
                suggestions: { templates: [], gaps: [], clusters: [] }
            };

            // Utility functions
            const utils = {
                escapeHtml: function(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                },

                setText: function(element, text) {
                    if (element) {
                        element.textContent = text || '';
                    }
                },

                setLoading: function(isLoading) {
                    state.isLoading = isLoading;
                    document.body.classList.toggle('loading', isLoading);
                },

                isValidPolicyArea: function(dimension) {
                    return CONFIG.DIMENSIONS.some(d => d.id === dimension);
                },

                isValidPhase: function(phase) {
                    return CONFIG.PHASES.some(p => p.id === phase);
                },

                isValidPolicy: function(dimension, phase, policy) {
                    return policyData[dimension] && 
                           policyData[dimension][phase] && 
                           policyData[dimension][phase][policy];
                },

                getPolicyKey: function(dimension, phase, policyId) {
                    return `${dimension}|${phase}|${policyId}`;
                },

                getPolicyAreaShortName: function(dimension) {
                    const mapping = {
                        'Enabling Infrastructure': 'infrastructure',
                        'Legislation & Policy': 'legislation',
                        'Sustainability & Society': 'sustainability',
                        'Economy & Innovation': 'economic',
                        'Research & Education': 'research'
                    };
                    return mapping[dimension] || 'infrastructure';
                },

                // Related policies functionality
                findRelatedPolicies: function(currentPolicyArea, currentPhase, currentPolicyId, limit = 5) {
                    if (!currentPolicyArea || !currentPhase || !currentPolicyId) return [];
                    
                    const currentPolicy = policyData[currentPolicyArea]?.[currentPhase]?.[currentPolicyId];
                    if (!currentPolicy || !Array.isArray(currentPolicy.keywords)) return [];
                    
                    const currentKeywords = currentPolicy.keywords.map(k => k.toLowerCase());
                    const relatedPolicies = [];
                    
                    // Search across all dimensions and phases
                    Object.entries(policyData).forEach(([dimension, phaseData]) => {
                        Object.entries(phaseData).forEach(([phase, policies]) => {
                            Object.entries(policies).forEach(([policyId, policyInfo]) => {
                                // Skip the current policy
                                if (dimension === currentPolicyArea && phase === currentPhase && policyId === currentPolicyId) {
                                    return;
                                }
                                
                                if (!Array.isArray(policyInfo.keywords)) return;
                                
                                const policyKeywords = policyInfo.keywords.map(k => k.toLowerCase());
                                
                                // Calculate keyword overlap
                                const sharedKeywords = currentKeywords.filter(k => 
                                    policyKeywords.some(pk => pk.includes(k) || k.includes(pk))
                                );
                                
                                if (sharedKeywords.length >= 1) { // Minimum 1 shared keyword
                                    // Calculate similarity score
                                    const similarityScore = sharedKeywords.length / Math.max(currentKeywords.length, policyKeywords.length);
                                    
                                    // Bonus for cross-dimensional relationships
                                    const crossPolicyAreaBonus = dimension !== currentPolicyArea ? 0.1 : 0;
                                    
                                    relatedPolicies.push({
                                        dimension,
                                        phase,
                                        policyId,
                                        policy: policyInfo.policy,
                                        keywords: policyInfo.keywords,
                                        sharedKeywords,
                                        similarityScore: similarityScore + crossPolicyAreaBonus,
                                        key: `${dimension}|${phase}|${policyId}`
                                    });
                                }
                            });
                        });
                    });
                    
                    // Sort by similarity score and return top results
                    return relatedPolicies
                        .sort((a, b) => b.similarityScore - a.similarityScore)
                        .slice(0, limit);
                },

                updateRelatedPolicies: function(currentPolicyArea, currentPhase, currentPolicyId) {
                    // Clear previous related policies
                    state.relatedPolicies.clear();
                    
                    if (!currentPolicyArea || !currentPhase || !currentPolicyId) {
                        return;
                    }
                    
                    // Find and store related policies
                    const related = this.findRelatedPolicies(currentPolicyArea, currentPhase, currentPolicyId);
                    related.forEach(rp => state.relatedPolicies.add(rp.key));
                }
            };

            // Smart Templates and Gap Analysis System
            const SMART_TEMPLATES = {
                'privacy-first': {
                    name: 'Privacy-First Approach',
                    policies: ['P25', 'P29', 'P51', 'P52', 'P62', 'P41', 'P43'],
                    triggers: ['privacy', 'data protection', 'rights', 'gdpr', 'personal data'],
                    description: 'Comprehensive data protection and privacy framework',
                    strategic_context: 'This approach prioritizes individual rights and data protection as the foundation for AI governance.'
                },
                'innovation-focused': {
                    name: 'Innovation-First Strategy',
                    policies: ['P9', 'P15', 'P16', 'P40', 'P69', 'P70', 'P89', 'P94'],
                    triggers: ['innovation', 'startup', 'sandbox', 'research', 'economic', 'funding'],
                    description: 'Promotes AI innovation through incentives and regulatory flexibility',
                    strategic_context: 'This strategy balances oversight with economic growth, using sandboxes and incentives to drive innovation.'
                },
                'comprehensive-governance': {
                    name: 'Comprehensive AI Governance',
                    policies: ['P1', 'P25', 'P31', 'P36', 'P39', 'P22', 'P41', 'P73', 'P76', 'P82'],
                    triggers: ['governance', 'regulation', 'compliance', 'oversight', 'framework'],
                    description: 'Full-spectrum AI governance covering all implementation phases',
                    strategic_context: 'This framework ensures systematic governance from analysis through monitoring and evaluation.'
                },
                'infrastructure-foundation': {
                    name: 'AI Infrastructure Foundation',
                    policies: ['P1', 'P4', 'P5', 'P8', 'P10', 'P17', 'P18', 'P22'],
                    triggers: ['infrastructure', 'computing', 'data centers', 'cloud', 'networks'],
                    description: 'Essential infrastructure for AI development and deployment',
                    strategic_context: 'Strong infrastructure is the foundation that enables all other AI governance initiatives.'
                }
            };

            const GAP_ANALYSIS_PATTERNS = {
                'missing-implementation': {
                    detect: (matrix) => {
                        const hasPlanning = (matrix.Analysis + matrix.Design) >= 3;
                        const hasImplementation = matrix.Implementation === 0;
                        return hasPlanning && hasImplementation;
                    },
                    message: "Strong planning foundation detected",
                    recommendation: "Consider adding implementation policies to operationalize your framework",
                    suggestions: ['P17', 'P36', 'P73', 'P94'],
                    priority: 'high'
                },
                'no-monitoring': {
                    detect: (matrix) => matrix.Monitoring === 0 && matrix.total >= 4,
                    message: "Comprehensive policy selection in progress",
                    recommendation: "Add monitoring policies to measure effectiveness and ensure continuous improvement",
                    suggestions: ['P22', 'P41', 'P82', 'P96'],
                    priority: 'medium'
                },
                'single-dimension': {
                    detect: (matrix) => {
                        const activePolicyAreas = Object.keys(matrix.byPolicyArea).filter(dim => matrix.byPolicyArea[dim] > 0);
                        return activePolicyAreas.length === 1 && matrix.total >= 3;
                    },
                    message: "Deep focus in one policy area established",
                    recommendation: "Consider policies from other dimensions for comprehensive coverage and cross-sector synergies",
                    suggestions: [], // Dynamic based on missing dimensions
                    priority: 'medium'
                },
                'infrastructure-gap': {
                    detect: (matrix) => {
                        const hasRegulation = (matrix.byPolicyArea['Legislation & Policy'] || 0) >= 2;
                        const hasInfrastructure = (matrix.byPolicyArea['Enabling Infrastructure'] || 0) === 0;
                        return hasRegulation && hasInfrastructure;
                    },
                    message: "Regulatory framework development in progress",
                    recommendation: "Infrastructure policies will help ensure your regulations can be effectively implemented",
                    suggestions: ['P1', 'P8', 'P17', 'P22'],
                    priority: 'high'
                }
            };


            // Enhanced Button System Class with Toggle Functionality
            class TPAFButtonSystem {
                constructor() {
                    this.dimensionNames = {
                        'Enabling Infrastructure': 'Enabling Infrastructure',
                        'Legislation & Policy': 'Legislation & Policy',
                        'Sustainability & Society': 'Sustainability & Society',
                        'Economy & Innovation': 'Economic Measures and Innovation',
                        'Research & Education': 'Research, Education & Capacity'
                    };
                    this.phaseNames = {
                        'Analysis': 'Analysis',
                        'Design': 'Design',
                        'Implementation': 'Implementation',
                        'Monitoring & Evaluation': 'Monitoring & Evaluation'
                    };
                }

                selectPolicyArea(dimension) {
                    // Toggle functionality: if same dimension is clicked, deselect it
                    if (state.selectedPolicyArea === dimension) {
                        // Deselect dimension
                        document.querySelectorAll('.dimension-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        // Hide phases section
                        dom.hidePhases();
                        
                        // Clear active phases
                        document.querySelectorAll('.phase-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        // Clear state and trigger deselection in main app
                        app.deselectPolicyArea();
                        
                        this.dispatchSelectionEvent();
                        return;
                    }

                    // Update active dimension button
                    document.querySelectorAll('.dimension-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-dimension="${dimension}"]`).classList.add('active');

                    // Show phases section with animation
                    dom.showPhases();
                    
                    // Clear active phases
                    document.querySelectorAll('.phase-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });

                    // Trigger dimension selection in main app
                    const dimConfig = CONFIG.DIMENSIONS.find(d => d.id === dimension);
                    if (dimConfig) {
                        app.selectPolicyArea(dimension, dimConfig.color);
                    }
                    
                    this.dispatchSelectionEvent();
                }

                selectPhase(phase) {
                    // Toggle functionality: if same phase is clicked, deselect it
                    if (state.selectedPhase === phase) {
                        // Deselect phase
                        document.querySelectorAll('.phase-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        // Trigger phase deselection in main app
                        app.deselectPhase();
                        
                        this.dispatchSelectionEvent();
                        return;
                    }

                    // Update active phase button
                    document.querySelectorAll('.phase-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-phase="${phase}"]`).classList.add('active');

                    // Trigger phase selection in main app
                    app.selectPhase(phase);
                    
                    this.dispatchSelectionEvent();
                }

                dispatchSelectionEvent() {
                    const event = new CustomEvent('tpafSelectionChange', {
                        detail: {
                            dimension: state.selectedPolicyArea,
                            phase: state.selectedPhase,
                            dimensionName: this.dimensionNames[state.selectedPolicyArea],
                            phaseName: this.phaseNames[state.selectedPhase]
                        }
                    });
                    document.dispatchEvent(event);
                }

                handleKeyboard(e) {
                    const activeElement = document.activeElement;
                    
                    if (activeElement.classList.contains('dimension-btn')) {
                        this.handlePolicyAreaKeyboard(e, activeElement);
                    } else if (activeElement.classList.contains('phase-btn')) {
                        this.handlePhaseKeyboard(e, activeElement);
                    }
                }

                handlePolicyAreaKeyboard(e, activeBtn) {
                    const dimensionBtns = Array.from(document.querySelectorAll('.dimension-btn'));
                    const currentIndex = dimensionBtns.indexOf(activeBtn);
                    let newIndex;

                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'ArrowUp':
                            e.preventDefault();
                            newIndex = currentIndex > 0 ? currentIndex - 1 : dimensionBtns.length - 1;
                            dimensionBtns[newIndex].focus();
                            break;
                        case 'ArrowRight':
                        case 'ArrowDown':
                            e.preventDefault();
                            newIndex = currentIndex < dimensionBtns.length - 1 ? currentIndex + 1 : 0;
                            dimensionBtns[newIndex].focus();
                            break;
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            this.selectPolicyArea(activeBtn.dataset.dimension);
                            break;
                    }
                }

                handlePhaseKeyboard(e, activeBtn) {
                    const phaseBtns = Array.from(document.querySelectorAll('.phase-btn'));
                    const currentIndex = phaseBtns.indexOf(activeBtn);
                    let newIndex;

                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            newIndex = currentIndex > 0 ? currentIndex - 1 : phaseBtns.length - 1;
                            phaseBtns[newIndex].focus();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            newIndex = currentIndex < phaseBtns.length - 1 ? currentIndex + 1 : 0;
                            phaseBtns[newIndex].focus();
                            break;
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            this.selectPhase(activeBtn.dataset.phase);
                            break;
                    }
                }
            }

            // DOM manipulation functions
            const dom = {
                createPolicyAreaButton: function(dimension, index) {
                    const button = document.createElement('button');
                    button.className = 'dimension-btn';
                    button.setAttribute('data-dimension', dimension.id);
                    button.setAttribute('aria-label', `Select ${dimension.id} dimension`);
                    
                    button.innerHTML = `
                        <img src="${dimension.coloredIcon}" alt="" class="dimension-icon" />
                        <div class="dimension-text">${utils.escapeHtml(dimension.short)}</div>
                    `;
                    
                    button.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (!state.isLoading && utils.isValidPolicyArea(dimension.id)) {
                            buttonSystem.selectPolicyArea(dimension.id);
                        }
                    });
                    
                    return button;
                },

                createPhaseButton: function(phase, index) {
                    const button = document.createElement('button');
                    button.className = 'phase-btn';
                    button.setAttribute('data-phase', phase.id);
                    button.setAttribute('aria-label', `Select ${phase.id} phase`);
                    
                    button.innerHTML = `${utils.escapeHtml(phase.short)}`;
                    
                    button.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (!state.isLoading && utils.isValidPhase(phase.id)) {
                            buttonSystem.selectPhase(phase.id);
                        }
                    });
                    
                    return button;
                },

                createPolicyItem: function(policyId, policyInfo) {
                    const policyKey = utils.getPolicyKey(state.selectedPolicyArea, state.selectedPhase, policyId);
                    const isSelected = state.selectedPolicies.has(policyKey);
                    
                    const button = document.createElement('button');
                    button.className = 'policy-item';
                    if (isSelected) {
                        button.classList.add('selected');
                    }
                    button.setAttribute('aria-label', `Select policy initiative ${policyId}: ${policyInfo.policy}`);
                    button.setAttribute('data-policy-id', policyId);
                    
                    const selectedIcon = isSelected ? '<div class="selected-icon">✓</div>' : '';
                    
                    button.innerHTML = `
                        <div class="policy-header">
                            <div class="policy-info">
                                <span class="policy-title">${utils.escapeHtml(policyInfo.policy)}</span>
                            </div>
                            ${selectedIcon}
                        </div>
                        <div class="policy-read-more">Read more →</div>
                    `;
                    
                    button.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (!state.isLoading && utils.isValidPolicy(state.selectedPolicyArea, state.selectedPhase, policyId)) {
                            app.selectPolicy(policyId);
                        }
                    });
                    
                    return button;
                },

                showPhases: function() {
                    const phasesSection = document.getElementById('phasesSection');
                    if (phasesSection) {
                        phasesSection.classList.add('visible');
                    }
                },

                hidePhases: function() {
                    const phasesSection = document.getElementById('phasesSection');
                    if (phasesSection) {
                        phasesSection.classList.remove('visible');
                    }
                }
            };

            // Initialize button system
            const buttonSystem = new TPAFButtonSystem();

            // Main application logic
            const app = {
                init: function() {
                    this.renderPolicyAreas();
                    this.renderPhases();
                    this.setupEventListeners();
                    this.generateSelectionGrid();
                    
                    // Initialize keyword filters (empty state)
                    this.populateKeywordFilters();
                    this.updateClearFiltersButton();
                    

                },

                renderPolicyAreas: function() {
                    const container = document.getElementById('dimensionGrid');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    CONFIG.DIMENSIONS.forEach((dimension, index) => {
                        const button = dom.createPolicyAreaButton(dimension, index);
                        container.appendChild(button);
                    });
                },

                renderPhases: function() {
                    const container = document.getElementById('phaseGrid');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    CONFIG.PHASES.forEach((phase, index) => {
                        const button = dom.createPhaseButton(phase, index);
                        container.appendChild(button);
                    });
                },

                setupEventListeners: function() {
                    const keywordsOverflow = document.getElementById('keywordsOverflow');
                    const keywordsTooltip = document.getElementById('keywordsTooltip');

                    if (keywordsOverflow && keywordsTooltip) {
                        keywordsOverflow.addEventListener('mouseenter', function() {
                            keywordsTooltip.classList.add('visible');
                        });

                        keywordsOverflow.addEventListener('mouseleave', function() {
                            keywordsTooltip.classList.remove('visible');
                        });
                    }

                    // Toggle button functionality
                    const policyListToggle = document.getElementById('policyListToggle');
                    if (policyListToggle) {
                        policyListToggle.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.togglePolicyListVisibility();
                        });
                    }
                    const selectPolicyBtn = document.getElementById('selectPolicyBtn');
                    if (selectPolicyBtn) {
                        selectPolicyBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            if (!state.isLoading) {
                                this.addPolicyToSelection();
                            }
                        });
                    }

                    // Clear all policies button
                    const clearAllBtn = document.getElementById('clearAllBtn');
                    if (clearAllBtn) {
                        clearAllBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.clearAllPolicies();
                        });
                    }

                    // Clear filters button
                    const clearFiltersBtn = document.getElementById('clearFiltersBtn');
                    if (clearFiltersBtn) {
                        clearFiltersBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.clearAllFilters();
                        });
                    }

                    // Search functionality
                    const searchInput = document.getElementById('policySearchInput');
                    if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                            state.searchTerm = e.target.value.toLowerCase();
                            
                            // Immediately show policy results when search is active
                            if (state.searchTerm || state.activeKeywords.size > 0) {
                                this.showPolicySection();
                                this.showPolicyList();
                            } else if (!state.selectedPolicyArea || !state.selectedPhase) {
                                // Hide policy section if no filters and no dimension/phase selected
                                this.clearPolicyView();
                            }
                            
                            this.updateClearFiltersButton();


                        });

                        // Clear search when phase changes
                        searchInput.addEventListener('focus', () => {
                            if (state.searchTerm === '') {
                                searchInput.value = '';
                            }
                        });
                    }

                    // Keyword dropdown functionality
                    const keywordDropdown = document.getElementById('keywordDropdown');
                    if (keywordDropdown) {
                        keywordDropdown.addEventListener('change', (e) => {
                            const selectedKeyword = e.target.value;
                            if (selectedKeyword) {
                                this.addKeywordFilter(selectedKeyword);
                            }
                        });
                    }

                    // Keyboard navigation
                    document.addEventListener('keydown', (e) => {
                        buttonSystem.handleKeyboard(e);
                    });
                },

                selectPolicyArea: function(dimension, color) {
                    if (!utils.isValidPolicyArea(dimension)) return;
                    
                    utils.setLoading(true);
                    
                    state.selectedPolicyArea = dimension;
                    state.selectedPhase = null; // Clear phase selection
                    state.selectedPolicy = null; // Clear policy selection
                    
                    // Show policy section immediately when dimension is selected
                    this.showPolicySection();
                    
                    // Set dimension attribute for phase container styling
                    const phasesContainer = document.getElementById('phaseGrid');
                    if (phasesContainer) {
                        phasesContainer.setAttribute('data-dimension', dimension);
                    }
                    
                    // Show policies for all phases in the selected dimension
                    this.showPolicyList();
                    
                    // Clear policy details since no specific policy is selected
                    this.clearPolicyDetails();
                    
                    // Populate keywords for all dimensions (not dependent on selection)
                    this.populateKeywordFilters();
                    this.updateClearFiltersButton();
                    
                    this.updateCurrentSelection();
                    this.updateSelectionGrid();

                    utils.setLoading(false);
                },

                deselectPolicyArea: function() {
                    utils.setLoading(true);
                    
                    state.selectedPolicyArea = null;
                    state.selectedPhase = null;
                    state.selectedPolicy = null;
                    state.relatedPolicies.clear(); // Clear related policies

                    // Hide phases section and clear policy view
                    this.clearPolicyView();
                    
                    // Clear dimension attribute for phase container
                    const phasesContainer = document.getElementById('phaseGrid');
                    if (phasesContainer) {
                        phasesContainer.removeAttribute('data-dimension');
                    }
                    
                    // If there's still search or keyword filters, show those results
                    if (state.searchTerm || state.activeKeywords.size > 0) {
                        this.showPolicySection();
                        this.showPolicyList();
                    }
                    
                    this.updateCurrentSelection();
                    this.updateSelectionGrid();

                    utils.setLoading(false);
                },

                selectPhase: function(phase) {
                    if (!utils.isValidPhase(phase)) return;
                    
                    utils.setLoading(true);
                    
                    state.selectedPhase = phase;
                    state.selectedPolicy = null; // Clear policy selection
                    
                    // Clear search when phase changes but keep keyword filters
                    state.searchTerm = '';
                    
                    // Clear search input
                    const searchInput = document.getElementById('policySearchInput');
                    if (searchInput) {
                        searchInput.value = '';
                    }

                    this.showPolicySection();
                    this.showPolicyList(); // This will now filter the dimension's policies by phase
                    this.clearPolicyDetails(); // Clear details panel since no specific policy selected
                    
                    // Keywords don't need refreshing since they show all keywords now
                    this.updateClearFiltersButton();
                    
                    this.updateCurrentSelection();
                    this.updateSelectionGrid();

                    utils.setLoading(false);
                },

                deselectPhase: function() {
                    utils.setLoading(true);
                    
                    state.selectedPhase = null;
                    state.selectedPolicy = null;
                    state.relatedPolicies.clear(); // Clear related policies
                    
                    // Clear search input but keep keyword filters
                    const searchInput = document.getElementById('policySearchInput');
                    if (searchInput) {
                        searchInput.value = '';
                    }
                    state.searchTerm = '';

                    // If dimension is still selected or there are filters, show appropriate results
                    if (state.selectedPolicyArea || state.searchTerm || state.activeKeywords.size > 0) {
                        this.showPolicySection();
                        this.showPolicyList();
                    } else {
                        this.clearPolicyView();
                    }
                    
                    this.clearPolicyDetails();
                    
                    this.updateClearFiltersButton();
                    this.updateCurrentSelection();
                    this.updateSelectionGrid();
                    utils.setLoading(false);
                },

                showPolicySection: function() {
                    const section = document.getElementById('policySection');
                    if (section) {
                        section.classList.remove('hidden');
                    }
                },

                clearPolicyView: function() {
                    const section = document.getElementById('policySection');
                    if (section) {
                        section.classList.add('hidden');
                    }
                },

                showPolicyList: function() {
                    const title = document.getElementById('policyListTitle');
                    const list = document.getElementById('policyList');
                    const listColumn = document.querySelector('.policy-list-column');
                    
                    if (!title || !list) return;

                    // Primary workflow: Keyword/Search-driven exploration
                    if (state.searchTerm || state.activeKeywords.size > 0) {
                        // Show cross-dimensional results, optionally filtered by dimension/phase
                        return this.showFilteredResults();
                    }

                    // Secondary workflow: Traditional dimension-phase navigation
                    if (state.selectedPolicyArea && state.selectedPhase) {
                        // Show specific dimension-phase policies
                        return this.showPolicyAreaPhaseResults();
                    }

                    // Default empty state
                    list.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">🔍</div>
                            <div class="empty-state-text">
                                Search for policy initiatives or select a policy area to get started
                            </div>
                        </div>
                    `;
                },

                showFilteredResults: function() {
                    const title = document.getElementById('policyListTitle');
                    const list = document.getElementById('policyList');
                    const listColumn = document.querySelector('.policy-list-column');
                    
                    // Remove dimension-specific styling for cross-dimensional results
                    if (listColumn) {
                        if (state.selectedPolicyArea && state.selectedPhase) {
                            listColumn.setAttribute('data-dimension', state.selectedPolicyArea);
                        } else {
                            listColumn.removeAttribute('data-dimension');
                        }
                    }

                    // Build title based on active filters
                    let titleText = 'Search Results';
                    if (state.selectedPolicyArea && state.selectedPhase) {
                        titleText = `${state.selectedPolicyArea} - ${state.selectedPhase}`;
                    } else if (state.selectedPolicyArea) {
                        titleText = `${state.selectedPolicyArea} - All Phases`;
                    } else if (state.searchTerm || state.activeKeywords.size > 0) {
                        // Handle case where dimension is deselected but filters are active
                        let filterParts = [];
                        if (state.searchTerm) filterParts.push(`Search: "${state.searchTerm}"`);
                        if (state.activeKeywords.size > 0) {
                            const keywordCount = state.activeKeywords.size;
                            filterParts.push(`${keywordCount} keyword${keywordCount > 1 ? 's' : ''}`);
                        }
                        titleText = `Filtered Results (${filterParts.join(', ')})`;
                    }
                    
                    utils.setText(title, titleText);
                    
                    // Get filtered policies across all dimensions
                    const filteredPolicies = this.getGlobalFilteredPolicies();
                    const policyEntries = Object.entries(filteredPolicies);
                    
                    list.innerHTML = '';
                    
                    if (policyEntries.length > 0) {
                        policyEntries.forEach(([key, policyInfo]) => {
                            const policyItem = this.createCrossPolicyAreaPolicyItem(key, policyInfo);
                            list.appendChild(policyItem);
                        });
                    } else {
                        list.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">🔍</div>
                                <div class="empty-state-text">
                                    No policy initiatives found matching your search criteria
                                </div>
                            </div>
                        `;
                    }
                },

                showPolicyAreaPhaseResults: function() {
                    const title = document.getElementById('policyListTitle');
                    const list = document.getElementById('policyList');
                    const listColumn = document.querySelector('.policy-list-column');
                    
                    // Set dimension attribute for styling
                    if (listColumn && state.selectedPolicyArea) {
                        listColumn.setAttribute('data-dimension', state.selectedPolicyArea);
                    }

                    // Handle case where dimension is selected but no phase
                    if (state.selectedPolicyArea && !state.selectedPhase) {
                        utils.setText(title, `${state.selectedPolicyArea} - All Phases`);
                        
                        // Show all policies from all phases in the selected dimension
                        const allPoliciesInDimension = {};
                        const dimensionData = policyData[state.selectedPolicyArea] || {};
                        
                        Object.entries(dimensionData).forEach(([phase, policies]) => {
                            Object.entries(policies).forEach(([policyId, policyInfo]) => {
                                const key = `${state.selectedPolicyArea}|${phase}|${policyId}`;
                                allPoliciesInDimension[key] = {
                                    ...policyInfo,
                                    _dimension: state.selectedPolicyArea,
                                    _phase: phase,
                                    _policyId: policyId
                                };
                            });
                        });
                        
                        const policyEntries = Object.entries(allPoliciesInDimension);
                        list.innerHTML = '';
                        
                        if (policyEntries.length > 0) {
                            policyEntries.forEach(([key, policyInfo]) => {
                                const policyItem = this.createCrossPolicyAreaPolicyItem(key, policyInfo);
                                list.appendChild(policyItem);
                            });
                        } else {
                            list.innerHTML = `
                                <div class="empty-state">
                                    <div class="empty-state-icon">📋</div>
                                    <div class="empty-state-text">
                                        No policy initiatives available for this policy area
                                    </div>
                                </div>
                            `;
                        }
                        return;
                    }

                    // Original logic for when both dimension and phase are selected
                    utils.setText(title, `${state.selectedPolicyArea} - ${state.selectedPhase}`);
                    
                    const allPolicies = policyData[state.selectedPolicyArea]?.[state.selectedPhase] || {};
                    const policyEntries = Object.entries(allPolicies);
                    
                    list.innerHTML = '';
                    
                    if (policyEntries.length > 0) {
                        policyEntries.forEach(([policyId, policyInfo]) => {
                            const policyItem = dom.createPolicyItem(policyId, policyInfo);
                            list.appendChild(policyItem);
                        });
                    } else {
                        list.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">📋</div>
                                <div class="empty-state-text">
                                    No policy initiatives available for this combination
                                </div>
                            </div>
                        `;
                    }
                },
                getGlobalFilteredPolicies: function() {
                    const filteredPolicies = {};
                    
                    // Search across all dimensions and phases
                    Object.entries(policyData).forEach(([dimension, phaseData]) => {
                        // Apply dimension filter if selected
                        if (state.selectedPolicyArea && dimension !== state.selectedPolicyArea) return;
                        
                        Object.entries(phaseData).forEach(([phase, policies]) => {
                            // Apply phase filter if selected
                            if (state.selectedPhase && phase !== state.selectedPhase) return;
                            
                            Object.entries(policies).forEach(([policyId, policyInfo]) => {
                                let matchesSearch = true;
                                let matchesKeywords = true;

                                // Search term filter
                                if (state.searchTerm) {
                                    const searchableText = `${policyInfo.policy} ${policyInfo.details} ${policyInfo.examples || ''}`.toLowerCase();
                                    matchesSearch = searchableText.includes(state.searchTerm);
                                }

                                // Keyword filter
                                if (state.activeKeywords.size > 0) {
                                    const policyKeywords = Array.isArray(policyInfo.keywords) ? policyInfo.keywords : [];
                                    matchesKeywords = Array.from(state.activeKeywords).some(keyword =>
                                        policyKeywords.some(pk => pk.toLowerCase().includes(keyword.toLowerCase()))
                                    );
                                }

                                if (matchesSearch && matchesKeywords) {
                                    const key = `${dimension}|${phase}|${policyId}`;
                                    filteredPolicies[key] = {
                                        ...policyInfo,
                                        _dimension: dimension,
                                        _phase: phase,
                                        _policyId: policyId
                                    };
                                }
                            });
                        });
                    });

                    return filteredPolicies;
                },

                createCrossPolicyAreaPolicyItem: function(key, policyInfo) {
                    const [dimension, phase, policyId] = key.split('|');
                    const policyKey = utils.getPolicyKey(dimension, phase, policyId);
                    const isSelected = state.selectedPolicies.has(policyKey);
                    
                    const button = document.createElement('button');
                    button.className = 'policy-item cross-dimensional';
                    if (isSelected) {
                        button.classList.add('selected');
                    }
                    button.setAttribute('aria-label', `Select policy ${policyId}: ${policyInfo.policy}`);
                    button.setAttribute('data-policy-id', policyId);
                    button.setAttribute('data-dimension', dimension);
                    button.setAttribute('data-phase', phase);
                    
                    const selectedIcon = isSelected ? '<div class="selected-icon">✓</div>' : '';
                    const dimensionColor = this.getPolicyAreaColor(dimension);
                    
                    button.innerHTML = `
                        <div class="policy-header">
                            <div class="policy-info">
                                <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.25rem;">
                                    <span class="policy-id" style="background: ${dimensionColor}; color: white;">${utils.escapeHtml(policyId)}</span>
                                </div>
                                <span class="policy-title">${utils.escapeHtml(policyInfo.policy)}</span>
                            </div>
                            ${selectedIcon}
                        </div>
                        <div style="font-size: 0.7rem; color: var(--color-gray-500); margin-top: 0.25rem; font-style: italic; padding-left: 0.5rem;">
                            ${utils.escapeHtml(dimension)} - ${utils.escapeHtml(phase)}
                        </div>
                    `;
                    
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (!state.isLoading) {
                            this.selectCrossPolicyAreaPolicy(dimension, phase, policyId);
                        }
                    });
                    
                    return button;
                },

                selectCrossPolicyAreaPolicy: function(dimension, phase, policyId) {
                    // Clear any existing related policies first
                    state.relatedPolicies.clear();
                    
                    // Highlight the corresponding dimension and phase
                    this.highlightPolicyAreaAndPhase(dimension, phase);
                    
                    // Set the state to match the selected policy
                    state.selectedPolicyArea = dimension;
                    state.selectedPhase = phase;
                    state.selectedPolicy = policyId;

                    // Update UI to show the dimension and phase are selected
                    document.querySelectorAll('.dimension-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-dimension="${dimension}"]`)?.classList.add('active');

                    document.querySelectorAll('.phase-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-phase="${phase}"]`)?.classList.add('active');

                    // Show phases section
                    dom.showPhases();
                    
                    // Show policy section and details
                    this.showPolicySection();
                    this.showPolicyList();
                    this.showPolicyDetails(); // This will update related policies
                    
                    // Update everything else
                    this.updateCurrentSelection();
                },

                highlightPolicyAreaAndPhase: function(dimension, phase) {
                    // Add temporary highlighting to dimension button
                    const dimensionBtn = document.querySelector(`[data-dimension="${dimension}"]`);
                    if (dimensionBtn) {
                        dimensionBtn.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.3)';
                        setTimeout(() => {
                            dimensionBtn.style.boxShadow = '';
                        }, 2000);
                    }

                    // Add temporary highlighting to phase button
                    const phaseBtn = document.querySelector(`[data-phase="${phase}"]`);
                    if (phaseBtn) {
                        phaseBtn.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.3)';
                        setTimeout(() => {
                            phaseBtn.style.boxShadow = '';
                        }, 2000);
                    }
                },

                getFilteredPolicies: function(policies) {
                    // If no dimension selected, search across all policies
                    if (!state.selectedPolicyArea && (state.searchTerm || state.activeKeywords.size > 0)) {
                        return this.getCrossPolicyAreaFilteredPolicies();
                    }
                    
                    if (!state.searchTerm && state.activeKeywords.size === 0) {
                        return policies;
                    }

                    const filtered = {};
                    
                    Object.entries(policies).forEach(([policyId, policyInfo]) => {
                        let matchesSearch = true;
                        let matchesKeywords = true;

                        // Search term filter
                        if (state.searchTerm) {
                            const searchableText = `${policyInfo.policy} ${policyInfo.details} ${policyInfo.examples || ''}`.toLowerCase();
                            matchesSearch = searchableText.includes(state.searchTerm);
                        }

                        // Keyword filter
                        if (state.activeKeywords.size > 0) {
                            const policyKeywords = Array.isArray(policyInfo.keywords) ? policyInfo.keywords : [];
                            matchesKeywords = Array.from(state.activeKeywords).some(keyword =>
                                policyKeywords.some(pk => pk.toLowerCase().includes(keyword.toLowerCase()))
                            );
                        }

                        if (matchesSearch && matchesKeywords) {
                            filtered[policyId] = policyInfo;
                        }
                    });

                    return filtered;
                },

                getCrossPolicyAreaFilteredPolicies: function() {
                    const crossPolicyAreaPolicies = {};
                    
                    // Search across all dimensions and phases
                    Object.entries(policyData).forEach(([dimension, phaseData]) => {
                        Object.entries(phaseData).forEach(([phase, policies]) => {
                            Object.entries(policies).forEach(([policyId, policyInfo]) => {
                                let matchesSearch = true;
                                let matchesKeywords = true;

                                // Search term filter
                                if (state.searchTerm) {
                                    const searchableText = `${policyInfo.policy} ${policyInfo.details} ${policyInfo.examples || ''}`.toLowerCase();
                                    matchesSearch = searchableText.includes(state.searchTerm);
                                }

                                // Keyword filter
                                if (state.activeKeywords.size > 0) {
                                    const policyKeywords = Array.isArray(policyInfo.keywords) ? policyInfo.keywords : [];
                                    matchesKeywords = Array.from(state.activeKeywords).some(keyword =>
                                        policyKeywords.some(pk => pk.toLowerCase().includes(keyword.toLowerCase()))
                                    );
                                }

                                if (matchesSearch && matchesKeywords) {
                                    const key = `${dimension}|${phase}|${policyId}`;
                                    crossPolicyAreaPolicies[key] = {
                                        ...policyInfo,
                                        _dimension: dimension,
                                        _phase: phase,
                                        _policyId: policyId
                                    };
                                }
                            });
                        });
                    });

                    return crossPolicyAreaPolicies;
                },

                applyFilters: function() {
                    if (state.selectedPolicyArea && state.selectedPhase) {
                        this.showPolicyList();
                    } else if (state.searchTerm || state.activeKeywords.size > 0) {
                        this.showPolicyList(); // This will show cross-dimensional results
                    }
                },

                populateKeywordFilters: function() {
                    const keywordDropdown = document.getElementById('keywordDropdown');
                    if (!keywordDropdown) return;
                    
                    // Get ALL keywords from ALL dimensions and phases
                    const allKeywords = new Set();
                    
                    // Iterate through all policy data regardless of current selection
                    Object.values(policyData).forEach(dimensionData => {
                        Object.values(dimensionData).forEach(phaseData => {
                            Object.values(phaseData).forEach(policy => {
                                if (Array.isArray(policy.keywords)) {
                                    policy.keywords.forEach(keyword => {
                                        allKeywords.add(keyword);
                                    });
                                }
                            });
                        });
                    });

                    // Clear existing options
                    keywordDropdown.innerHTML = '<option value="">Filter by keyword...</option>';
                    keywordDropdown.disabled = false;
                    
                    if (allKeywords.size === 0) {
                        keywordDropdown.innerHTML = '<option value="">No keywords available</option>';
                        keywordDropdown.disabled = true;
                        return;
                    }
                    
                    // Add options for each keyword (sorted alphabetically)
                    const sortedKeywords = Array.from(allKeywords).sort();
                    sortedKeywords.forEach(keyword => {
                        const option = document.createElement('option');
                        option.value = keyword;
                        option.textContent = keyword;
                        keywordDropdown.appendChild(option);
                    });

                    // Update active keywords display
                    this.updateActiveKeywordsDisplay();
                },
                 
                // Replace the existing updateActiveKeywordsDisplay function with:
                updateActiveKeywordsDisplay: function() {
                    const visibleKeywords = document.getElementById('visibleKeywords');
                    const keywordsOverflow = document.getElementById('keywordsOverflow');
                    const tooltipKeywords = document.getElementById('tooltipKeywords');
                    
                    if (!visibleKeywords) return;

                    // Clear current display
                    visibleKeywords.innerHTML = '';
                    if (tooltipKeywords) tooltipKeywords.innerHTML = '';
                    
                    if (state.activeKeywords.size === 0) {
                        if (keywordsOverflow) keywordsOverflow.style.display = 'none';
                        return;
                    }

                    const keywordsArray = Array.from(state.activeKeywords);
                    
                    // Show visible chips
                    const visibleChips = keywordsArray.slice(0, maxVisibleChips);
                    visibleChips.forEach(keyword => {
                        const chip = this.createKeywordChip(keyword);
                        visibleKeywords.appendChild(chip);
                    });

                    // Handle overflow
                    const overflowCount = keywordsArray.length - maxVisibleChips;
                    if (overflowCount > 0 && keywordsOverflow) {
                        keywordsOverflow.textContent = `+${overflowCount} more`;
                        keywordsOverflow.style.display = 'flex';
                        
                        // Add all chips to tooltip
                        if (tooltipKeywords) {
                            keywordsArray.forEach(keyword => {
                                const chip = this.createKeywordChip(keyword);
                                tooltipKeywords.appendChild(chip);
                            });
                        }
                    } else if (keywordsOverflow) {
                        keywordsOverflow.style.display = 'none';
                    }
                },

                // Add this new function:
                createKeywordChip: function(keyword) {
                    const chip = document.createElement('div');
                    chip.className = 'keyword-chip';
                    chip.innerHTML = `
                        <span class="keyword-chip-text">${utils.escapeHtml(keyword)}</span>
                        <button class="keyword-chip-remove">×</button>
                    `;
                    
                    // Add the event listener properly
                    const removeBtn = chip.querySelector('.keyword-chip-remove');
                    removeBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.removeKeywordFilter(keyword);
                    });
                    
                    return chip;
                },
                addKeywordFilter: function(keyword) {
                    if (!keyword || state.activeKeywords.has(keyword)) return;
                    
                    state.activeKeywords.add(keyword);
                    this.updateActiveKeywordsDisplay();
                    
                    // Immediately show policy results when keywords are selected
                    this.showPolicySection();
                    this.showPolicyList();
                    
                    this.updateClearFiltersButton();
                    
                    // Reset dropdown
                    const dropdown = document.getElementById('keywordDropdown');
                    if (dropdown) {
                        dropdown.value = '';
                    }

                },

                removeKeywordFilter: function(keyword) {
                    state.activeKeywords.delete(keyword);
                    this.updateActiveKeywordsDisplay();
                    
                    // If no more keywords or search terms, hide policy section
                    if (state.activeKeywords.size === 0 && !state.searchTerm) {
                        this.clearPolicyView();
                    } else {
                        this.showPolicyList();
                    }
                    
                    this.updateClearFiltersButton();
                },

                toggleKeywordFilter: function(keyword) {
                    // This function is now replaced by addKeywordFilter
                    this.addKeywordFilter(keyword);
                },

                clearAllFilters: function() {
                    // Clear search
                    state.searchTerm = '';
                    const searchInput = document.getElementById('policySearchInput');
                    if (searchInput) {
                        searchInput.value = '';
                    }
                    
                    // Clear keyword filters
                    state.activeKeywords.clear();
                    
                    // Update active keywords display
                    this.updateActiveKeywordsDisplay();
                    
                    // Reset dropdown
                    const dropdown = document.getElementById('keywordDropdown');
                    if (dropdown) {
                        dropdown.value = '';
                    }
                    
                    // Hide policy section if no dimension/phase selected
                    if (!state.selectedPolicyArea || !state.selectedPhase) {
                        this.clearPolicyView();
                    } else {
                        // Refresh policy list to show dimension-phase results
                        this.showPolicyList();
                    }
                    
                    // Update button visibility
                    this.updateClearFiltersButton();
                },

                updateClearFiltersButton: function() {
                    const clearBtn = document.getElementById('clearFiltersBtn');
                    if (clearBtn) {
                        const hasActiveFilters = state.searchTerm || state.activeKeywords.size > 0;
                        clearBtn.style.display = hasActiveFilters ? 'block' : 'none';
                    }
                },

                selectPolicy: function(policyId) {
                    if (!utils.isValidPolicy(state.selectedPolicyArea, state.selectedPhase, policyId)) return;
                    
                    utils.setLoading(true);
                    
                    state.selectedPolicy = policyId;

                    document.querySelectorAll('.policy-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    
                    const selectedItem = document.querySelector(`[data-policy-id="${policyId}"]`);
                    if (selectedItem) {
                        selectedItem.classList.add('active');
                    }

                    // Show the details panel when a policy is selected
                    const policyContainer = document.getElementById('policyContainer');
                    const policyDetailsColumn = document.getElementById('policyDetailsColumn');

                    if (policyContainer && policyDetailsColumn) {
                        policyContainer.classList.add('details-focused');
                        policyDetailsColumn.classList.add('has-policy');
                    }

                    this.showPolicyDetails(); // This will update related policies and matrix
                    this.updateCurrentSelection();
                    
                    utils.setLoading(false);
                },

                showPolicyDetails: function() {
                    const policyContainer = document.getElementById('policyContainer');
                    const policyDetailsColumn = document.getElementById('policyDetailsColumn');

                    if (policyContainer && policyDetailsColumn) {
                        policyContainer.classList.add('details-focused');
                        policyDetailsColumn.classList.add('has-policy');
                    }
                    const policyInfo = policyData[state.selectedPolicyArea]?.[state.selectedPhase]?.[state.selectedPolicy];
                    if (!policyInfo) return;
                    
                    const detailsContent = document.getElementById('policyDetailsContent');
                    const selectPolicyBtn = document.getElementById('selectPolicyBtn');
                    
                    if (!detailsContent) return;
                    
                    const policyKey = utils.getPolicyKey(state.selectedPolicyArea, state.selectedPhase, state.selectedPolicy);
                    const isSelected = state.selectedPolicies.has(policyKey);
                    
                    // Update related policies
                    utils.updateRelatedPolicies(state.selectedPolicyArea, state.selectedPhase, state.selectedPolicy);
                    
                    //Update relevant experts based on current policy
                    updateRelevantExperts(state.selectedPolicy);
                    
                    // Find related policies for display
                    const relatedPolicies = utils.findRelatedPolicies(state.selectedPolicyArea, state.selectedPhase, state.selectedPolicy);
                    
                    // Generate contextual explanation for related policies
                    let relationshipContext = '';
                    if (relatedPolicies.length > 0) {
                        const crossPolicyAreaCount = relatedPolicies.filter(rp => rp.dimension !== state.selectedPolicyArea).length;
                    }
                    
                    detailsContent.innerHTML = `
                        <div class="detail-section">
                            <h3>Initiative Overview</h3>
                            <p>${utils.escapeHtml(policyInfo.policy)}</p>
                        </div>
                        
                        <div class="detail-section">
                            <h3>Possible Implementation Guidance and Actions</h3>
                            <p>${utils.escapeHtml(policyInfo.details)}</p>
                        </div>
                        
                        ${policyInfo.examples ? `
                        <div class="detail-section">
                            <h3>Implementation Examples</h3>
                            <div class="examples-box">
                                ${utils.escapeHtml(policyInfo.examples)}
                            </div>
                        </div>
                        ` : ''}
                        
                        <div class="detail-section">
                            <h3>Keywords</h3>
                            <div class="keywords-container">
                                ${policyInfo.keywords.map(keyword => 
                                    `<span class="keyword">${utils.escapeHtml(keyword)}</span>`
                                ).join('')}
                            </div>
                        </div>
                        
                        ${relatedPolicies.length > 0 ? `
                        <div class="related-policies-section">
                            <h3>
                                Related Policy Initiatives
                                <span style="font-size: 0.7rem; font-weight: normal; color: var(--color-gray-500);">
                                    (${relatedPolicies.length} found)
                                </span>
                            </h3>
                            
                            ${relationshipContext ? `
                            <div class="policy-relationship-context">
                                ${relationshipContext}
                            </div>
                            ` : ''}
                            
                            <div class="related-policies-list">
                                ${relatedPolicies.map(related => `
                                    <div class="related-policy-item" data-dimension="${utils.escapeHtml(related.dimension)}" data-phase="${utils.escapeHtml(related.phase)}" data-policy-id="${utils.escapeHtml(related.policyId)}">
                                        <div class="related-policy-dimension" style="background-color: ${this.getPolicyAreaColor(related.dimension)}">
                                            ${this.getPolicyAreaInitial(related.dimension)}
                                        </div>
                                        <div class="related-policy-content">
                                            <div class="related-policy-header">
                                                <span class="related-policy-id">${utils.escapeHtml(related.policyId)}</span>
                                                <span class="related-policy-phase">${utils.escapeHtml(related.phase)}</span>
                                            </div>
                                            <div class="related-policy-title">${utils.escapeHtml(related.policy)}</div>
                                            <div class="related-policy-match">
                                                ${related.dimension !== state.selectedPolicyArea ? 'Cross Policy Areas • ' : ''}Shared: ${related.sharedKeywords.join(', ')}
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                            
                            <!-- <div class="related-policies-explanation">
                                Related policies are shown based on shared keywords and strategic complementarity. <br> Click any related policy to navigate to it, or view them in the Implementation Plan Dashboard above as highlighted bars.
                            </div> -->
                        </div>
                        ` : ''}
                    `;

                    // Add click handlers for related policies
                    detailsContent.querySelectorAll('.related-policy-item').forEach(item => {
                        item.addEventListener('click', (e) => {
                            e.preventDefault();
                            const dimension = item.dataset.dimension;
                            const phase = item.dataset.phase;
                            const policyId = item.dataset.policyId;
                            this.navigateToPolicy(dimension, phase, policyId);
                        });
                    });

                    if (selectPolicyBtn) {
                        utils.setText(selectPolicyBtn, isSelected ? 'Selected' : 'Add policy initiative to your plan ➕');
                        selectPolicyBtn.disabled = isSelected;
                        selectPolicyBtn.classList.remove('hidden');
                    }
                    
                    // Update matrix to show related policies
                    this.updateSelectionGrid();
                },

                clearPolicyDetails: function() {
                    // Remove details-focused class to hide details panel
                    const policyContainer = document.getElementById('policyContainer');
                    const policyDetailsColumn = document.getElementById('policyDetailsColumn');

                    if (policyContainer && policyDetailsColumn) {
                        policyContainer.classList.remove('details-focused');
                        policyDetailsColumn.classList.remove('has-policy');
                    }
                    
                    const detailsContent = document.getElementById('policyDetailsContent');
                    const selectPolicyBtn = document.getElementById('selectPolicyBtn');
                    
                    // Clear related policies when clearing details
                    state.relatedPolicies.clear();
                    
                    // Reset experts to default view (no specific policy selected)
                    updateRelevantExperts();
                    
                    if (detailsContent) {
                        detailsContent.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">📄</div>
                                <div class="empty-state-text">
                                    Select a policy from the list<br>to view its details
                                </div>
                            </div>
                        `;
                    }
                    
                    if (selectPolicyBtn) {
                        selectPolicyBtn.classList.add('hidden');
                    }
                    
                    // Update matrix to remove related policy visualization
                    this.updateSelectionGrid();
                },



                navigateToPolicy: function(dimension, phase, policyId) {
                    // Update navigation state
                    state.selectedPolicyArea = dimension;
                    state.selectedPhase = phase;
                    state.selectedPolicy = policyId;

                    // Update UI buttons
                    document.querySelectorAll('.dimension-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-dimension="${dimension}"]`)?.classList.add('active');

                    document.querySelectorAll('.phase-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-phase="${phase}"]`)?.classList.add('active');

                    // Set dimension attribute for phase container styling
                    const phasesContainer = document.getElementById('phaseGrid');
                    if (phasesContainer) {
                        phasesContainer.setAttribute('data-dimension', dimension);
                    }

                    // Show phases section
                    dom.showPhases();
                    
                    // Show policy section and update lists
                    this.showPolicySection();
                    this.showPolicyList();
                    
                    // Select the specific policy in the list
                    document.querySelectorAll('.policy-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    
                    const targetPolicyItem = document.querySelector(`[data-policy-id="${policyId}"]`);
                    if (targetPolicyItem) {
                        targetPolicyItem.classList.add('active');
                        targetPolicyItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Add temporary highlight
                        targetPolicyItem.style.backgroundColor = '#fef3c7';
                        setTimeout(() => {
                            targetPolicyItem.style.backgroundColor = '';
                        }, 2000);
                    }
                    
                    // Show policy details
                    this.showPolicyDetails();
                    
                    // Update everything else
                    this.updateCurrentSelection();
                },

                addPolicyToSelection: function() {
                    if (!state.selectedPolicy) return;
                    
                    const policyKey = utils.getPolicyKey(state.selectedPolicyArea, state.selectedPhase, state.selectedPolicy);
                    state.selectedPolicies.add(policyKey);
                    
                    const selectedPolicy = document.querySelector('.policy-item.active');
                    if (selectedPolicy) {
                        selectedPolicy.classList.add('pulse');
                        setTimeout(() => selectedPolicy.classList.remove('pulse'), 500);
                    }
                    
                    this.showPolicyList();
                    this.showPolicyDetails();
                    this.updateSelectionGrid();
                    this.updateSelectedPoliciesSection();

                },

                clearAllPolicies: function() {
                    if (state.selectedPolicies.size === 0) return;
                    
                    if (confirm(`Are you sure you want to clear all ${state.selectedPolicies.size} selected policy initiatives?`)) {
                        state.selectedPolicies.clear();
                        this.updateSelectionGrid();
                        this.updateSelectedPoliciesSection();
                        this.showPolicyList(); // Refresh to update selected indicators
                        this.showPolicyDetails(); // Refresh to update select button

                    }
                },

                removePolicyFromSelection: function(policyKey) {
                    state.selectedPolicies.delete(policyKey);
                    this.updateSelectionGrid();
                    this.updateSelectedPoliciesSection();
                    this.showPolicyList(); // Refresh to update selected indicators
                    this.showPolicyDetails(); // Refresh to update select button if current policy was removed

                },


                // Apply a template by selecting all its policies
                applyTemplate: function(templateKey) {
                    const template = SMART_TEMPLATES[templateKey];
                    if (!template) return;
                    
                    let addedCount = 0;
                    const errors = [];
                    
                    template.policies.forEach(policyId => {
                        const policyLocation = this.findPolicyLocation(policyId);
                        if (policyLocation) {
                            const policyKey = utils.getPolicyKey(policyLocation.dimension, policyLocation.phase, policyId);
                            if (!state.selectedPolicies.has(policyKey)) {
                                state.selectedPolicies.add(policyKey);
                                addedCount++;
                            }
                        } else {
                            errors.push(policyId);
                        }
                    });
                    
                    // Update all relevant UI components
                    this.updateSelectionGrid();
                    this.updateSelectedPoliciesSection();
                    this.showPolicyList();
                    this.showPolicyDetails();

                    
                    // Show feedback to user
                    if (addedCount > 0) {
                        const message = `Added ${addedCount} policies from ${template.name} template.`;
                        this.showTemporaryMessage(message, 'success');
                    }
                    
                    if (errors.length > 0) {
                        console.warn('Could not find policies:', errors);
                    }
                },

                // Navigate to a specific policy by ID
                navigateToPolicyById: function(policyId) {
                    const policyLocation = this.findPolicyLocation(policyId);
                    if (policyLocation) {
                        this.navigateToPolicy(policyLocation.dimension, policyLocation.phase, policyId);
                        
                        // Show temporary highlight message
                        this.showTemporaryMessage(`Navigated to policy ${policyId}`, 'info');
                    } else {
                        console.error('Policy not found:', policyId);
                    }
                },

                // Find which dimension and phase a policy ID belongs to
                findPolicyLocation: function(policyId) {
                    for (const dimension of Object.keys(policyData)) {
                        for (const phase of Object.keys(policyData[dimension])) {
                            if (policyData[dimension][phase][policyId]) {
                                return { dimension, phase };
                            }
                        }
                    }
                    return null;
                },

                // Show temporary feedback messages
                showTemporaryMessage: function(message, type = 'info') {
                    const messageEl = document.createElement('div');
                    messageEl.className = `temp-message temp-message-${type}`;
                    messageEl.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                        color: white;
                        padding: 12px 20px;
                        border-radius: 6px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 10000;
                        font-size: 0.875rem;
                        max-width: 300px;
                        transform: translateX(400px);
                        transition: transform 0.3s ease;
                    `;
                    messageEl.textContent = message;
                    
                    document.body.appendChild(messageEl);
                    
                    // Animate in
                    setTimeout(() => {
                        messageEl.style.transform = 'translateX(0)';
                    }, 10);
                    
                    // Animate out and remove
                    setTimeout(() => {
                        messageEl.style.transform = 'translateX(400px)';
                        setTimeout(() => {
                            if (messageEl.parentNode) {
                                messageEl.parentNode.removeChild(messageEl);
                            }
                        }, 300);
                    }, 3000);
                },


                highlightSelectedPolicy: function(policyKey) {
                    // Remove previous highlights
                    document.querySelectorAll('.selected-policy-item').forEach(item => {
                        item.classList.remove('highlighted');
                    });
                    
                    // Add highlight to target policy
                    const targetItem = document.querySelector(`[data-policy-key="${policyKey}"]`);
                    if (targetItem) {
                        targetItem.classList.add('highlighted');
                        targetItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Remove highlight after 3 seconds
                        setTimeout(() => {
                            targetItem.classList.remove('highlighted');
                        }, 3000);
                    }
                },

                updateSelectedPoliciesSection: function() {
                    const section = document.getElementById('selectedPoliciesSection');
                    const countElement = document.getElementById('selectedPoliciesCount');
                    const listElement = document.getElementById('selectedPoliciesList');
                    const clearAllBtn = document.getElementById('clearAllBtn');
                    
                    if (!section || !countElement || !listElement) return;
                    
                    const selectedCount = state.selectedPolicies.size;
                    
                    // Update count
                    countElement.textContent = `${selectedCount} ${selectedCount === 1 ? 'policy' : 'policies'} selected`;
                    
                    // Enable/disable clear all button
                    if (clearAllBtn) {
                        clearAllBtn.disabled = selectedCount === 0;
                    }
                    
                    // Show/hide section
                    if (selectedCount === 0) {
                        section.classList.add('hidden');
                        listElement.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">📋</div>
                                <div class="empty-state-text">
                                    No policy initiatives selected yet. Select initiatives to see them here
                                </div>
                            </div>
                        `;
                        return;
                    }
                    
                    section.classList.remove('hidden');
                    
                    // Populate list
                    listElement.innerHTML = '';
                    
                    // Group policies by dimension
                    const policiesByPolicyArea = {};
                    Array.from(state.selectedPolicies).forEach(policyKey => {
                        const [dimension, phase, policyId] = policyKey.split('|');
                        if (!policiesByPolicyArea[dimension]) {
                            policiesByPolicyArea[dimension] = [];
                        }
                        policiesByPolicyArea[dimension].push({ policyKey, dimension, phase, policyId });
                    });
                    
                    // Render each dimension's policies
                    Object.entries(policiesByPolicyArea).forEach(([dimension, policies]) => {
                        policies.forEach(({ policyKey, dimension, phase, policyId }) => {
                            const policyInfo = policyData[dimension]?.[phase]?.[policyId];
                            if (!policyInfo) return;
                            
                            const item = document.createElement('div');
                            item.className = 'selected-policy-item';
                            item.setAttribute('data-policy-key', policyKey);
                            
                            const dimensionColor = this.getPolicyAreaColor(dimension);
                            const dimensionInitial = this.getPolicyAreaInitial(dimension);
                            
                            item.innerHTML = `
                                <div class="selected-policy-dimension" style="background-color: ${dimensionColor}">
                                    ${dimensionInitial}
                                </div>
                                <div class="selected-policy-content">
                                    <div class="selected-policy-header">
                                        <span class="selected-policy-id">${utils.escapeHtml(policyId)}</span>
                                        <span class="selected-policy-phase">${utils.escapeHtml(phase)}</span>
                                    </div>
                                    <div class="selected-policy-title">${utils.escapeHtml(policyInfo.policy)}</div>
                                </div>
                                <div class="selected-policy-actions">
                                    <button class="remove-policy-btn" title="Remove this policy" data-policy-key="${policyKey}">
                                        ×
                                    </button>
                                </div>
                            `;
                            
                            // Add click handler for highlighting
                            item.addEventListener('click', (e) => {
                                if (!e.target.classList.contains('remove-policy-btn')) {
                                    this.highlightSelectedPolicy(policyKey);
                                }
                            });
                            
                            // Add remove button handler
                            const removeBtn = item.querySelector('.remove-policy-btn');
                            removeBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                this.removePolicyFromSelection(policyKey);
                            });
                            
                            listElement.appendChild(item);
                        });
                    });
                },

                getPolicyAreaInitial: function(dimension) {
                    const initials = {
                        'Enabling Infrastructure': 'I',
                        'Legislation & Policy': 'L',
                        'Sustainability & Society': 'S',
                        'Economy & Innovation': 'E',
                        'Research & Education': 'R'
                    };
                    return initials[dimension] || 'P';
                },

                // matrix grid
                generateSelectionGrid: function() {
                    const grid = document.getElementById('selectionGrid');
                    if (!grid) return;
                    
                    grid.innerHTML = '';
                    
                    const phases = ['Monitoring and Evaluation', 'Implementation', 'Design', 'Analysis'];
                    const dimensions = CONFIG.DIMENSIONS.map(d => d.id);
                    
                    // Create grid cells (4 rows x 5 columns)
                    phases.forEach((phase, phaseIndex) => {
                        dimensions.forEach((dimension, dimIndex) => {
                            const cell = document.createElement('div');
                            cell.className = 'grid-cell';
                            cell.setAttribute('data-dimension', dimension);
                            cell.setAttribute('data-phase', phase);
                            
                            // Add selection indicator
                            if (state.selectedPolicyArea === dimension && state.selectedPhase === phase) {
                                cell.classList.add('selected');
                            }
                            
                            // Create bars container
                            const barsContainer = document.createElement('div');
                            barsContainer.className = 'policy-bars';
                            
                            // Add bars for selected policies in this cell
                            this.addPolicyBarsToCell(barsContainer, dimension, phase);
                            
                            cell.appendChild(barsContainer);
                            grid.appendChild(cell);
                        });
                    });
                },

                addPolicyBarsToCell: function(container, dimension, phase) {
                    // Find all selected policies for this dimension-phase combination
                    const selectedPoliciesInCell = Array.from(state.selectedPolicies).filter(policyKey => {
                        const [dim, ph, policyId] = policyKey.split('|');
                        return dim === dimension && ph === phase;
                    });

                    // Find related policies for this cell (only if viewing a policy)
                    const relatedPoliciesInCell = Array.from(state.relatedPolicies).filter(policyKey => {
                        const [dim, ph, policyId] = policyKey.split('|');
                        return dim === dimension && ph === phase;
                    });

                    // Get all policies for this cell (selected + related)
                    const allPoliciesInCell = [...selectedPoliciesInCell, ...relatedPoliciesInCell];
                    
                    if (allPoliciesInCell.length === 0) return;

                    // Get dimension color
                    const dimColor = this.getPolicyAreaColor(dimension);
                    
                    // Calculate dynamic bar height based on number of policies
                    const maxCellHeight = 52; // Available height in cell (60px - padding)
                    const minBarHeight = 4;
                    const maxBarHeight = 16;
                    const gapHeight = 1; // Gap between bars
                    
                    const policyCount = allPoliciesInCell.length;
                    let barHeight = minBarHeight;
                    
                    if (policyCount > 0) {
                        const totalGapHeight = (policyCount - 1) * gapHeight;
                        const availableHeight = maxCellHeight - totalGapHeight;
                        barHeight = Math.max(minBarHeight, Math.min(maxBarHeight, Math.floor(availableHeight / policyCount)));
                    }
                    
                    // Create bars for each policy (selected first, then related)
                    selectedPoliciesInCell.forEach(policyKey => {
                        this.createPolicyBar(container, policyKey, dimColor, barHeight, 'selected');
                    });

                    relatedPoliciesInCell.forEach(policyKey => {
                        this.createPolicyBar(container, policyKey, dimColor, barHeight, 'related');
                    });
                },

                createPolicyBar: function(container, policyKey, dimColor, barHeight, type) {
                    const [dim, ph, policyId] = policyKey.split('|');
                    const policyInfo = policyData[dim]?.[ph]?.[policyId];
                    const policyTitle = policyInfo ? `${policyId}: ${policyInfo.policy}` : `${policyId}`;
                    
                    const bar = document.createElement('div');
                    bar.className = `policy-bar ${type}`;
                    bar.style.backgroundColor = dimColor;
                    bar.style.height = `${barHeight}px`;
                    bar.setAttribute('data-policy-key', policyKey);
                    bar.setAttribute('data-dimension', dim);
                    bar.setAttribute('data-phase', ph);
                    bar.setAttribute('data-policy-id', policyId);
                    
                    // Check if this is the currently viewing policy
                    if (state.selectedPolicyArea === dim && state.selectedPhase === ph && state.selectedPolicy === policyId) {
                        bar.classList.add('current-viewing');
                    }
                    
                    // Add hover functionality
                    this.addBarTooltip(bar, policyInfo, dim, ph, policyId, type);
                    
                    // Add click handler
                    bar.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        if (type === 'selected') {
                            // For selected policies, highlight them in the selected policies section
                            this.highlightSelectedPolicy(policyKey);
                        } else {
                            // For related policies, navigate to view them
                            this.navigateToPolicy(dim, ph, policyId);
                        }
                    });
                    
                    container.appendChild(bar);
                },

                addBarTooltip: function(bar, policyInfo, dimension, phase, policyId, type) {
                    let tooltip = null;
                    let documentClickHandler = null;
                    let documentKeyHandler = null;
                    let scrollHandler = null;
                    
                    const showTooltip = (e) => {
                        if (tooltip) return; // Prevent multiple tooltips
                        
                        tooltip = document.createElement('div');
                        tooltip.className = 'policy-bar-tooltip';
                        
                        const typeLabel = type === 'selected' ? 'Selected Policy' : 'Related Policy';
                        const matchInfo = type === 'related' && state.selectedPolicy ? 
                            '<div style="font-size: 0.65rem; opacity: 0.8; margin-top: 0.25rem;">Click to view details</div>' : '';
                        
                        tooltip.innerHTML = `
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">${utils.escapeHtml(policyId)}</div>
                            <div style="margin-bottom: 0.25rem;">${utils.escapeHtml(policyInfo?.policy || 'Policy details unavailable')}</div>
                            <div style="font-size: 0.65rem; opacity: 0.8;">
                                ${utils.escapeHtml(dimension)} • ${utils.escapeHtml(phase)}
                            </div>
                            <div style="font-size: 0.65rem; color: ${type === 'selected' ? '#10b981' : '#f59e0b'}; margin-top: 0.25rem;">
                                ${typeLabel}
                            </div>
                            ${matchInfo}
                        `;
                        
                        document.body.appendChild(tooltip);
                        
                        // Position tooltip
                        const rect = bar.getBoundingClientRect();
                        const tooltipRect = tooltip.getBoundingClientRect();
                        
                        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
                        let top = rect.top - tooltipRect.height - 8;
                        
                        // Keep tooltip in viewport
                        left = Math.max(8, Math.min(left, window.innerWidth - tooltipRect.width - 8));
                        if (top < 8) {
                            top = rect.bottom + 8;
                        }
                        
                        tooltip.style.left = `${left}px`;
                        tooltip.style.top = `${top}px`;
                        tooltip.classList.add('visible');
                        
                        // Create event handlers
                        documentClickHandler = (e) => {
                            if (!bar.contains(e.target) && !tooltip.contains(e.target)) {
                                hideTooltip();
                            }
                        };
                        
                        documentKeyHandler = (e) => {
                            if (e.key === 'Escape') {
                                hideTooltip();
                            }
                        };
                        
                        scrollHandler = () => {
                            hideTooltip();
                        };
                        
                        // Add event listeners
                        document.addEventListener('click', documentClickHandler);
                        document.addEventListener('keydown', documentKeyHandler);
                        window.addEventListener('scroll', scrollHandler);
                    };
                    
                    const hideTooltip = () => {
                        if (tooltip) {
                            tooltip.remove();
                            tooltip = null;
                        }
                        
                        // Remove all event listeners
                        if (documentClickHandler) {
                            document.removeEventListener('click', documentClickHandler);
                            documentClickHandler = null;
                        }
                        if (documentKeyHandler) {
                            document.removeEventListener('keydown', documentKeyHandler);
                            documentKeyHandler = null;
                        }
                        if (scrollHandler) {
                            window.removeEventListener('scroll', scrollHandler);
                            scrollHandler = null;
                        }
                    };
                    
                    // Bar event listeners
                    bar.addEventListener('mouseenter', showTooltip);
                    bar.addEventListener('mouseleave', hideTooltip);
                    bar.addEventListener('click', hideTooltip);
                },
                getPolicyAreaColor: function(dimension) {
                    const colorMapping = {
                        'Enabling Infrastructure': 'rgb(22, 102, 106)',
                        'Legislation & Policy': '#cb9b3d',
                        'Sustainability & Society': '#5f0085',
                        'Economy & Innovation': '#8b2f30',
                        'Research & Education': '#005b3a'
                    };
                    return colorMapping[dimension] || '#666';
                },

                updateSelectionGrid: function() {
                    this.generateSelectionGrid();
                },

                updateCurrentSelection: function() {
                    const infoElement = document.getElementById('selectionInfo');
                    const exportInfoElement = document.getElementById('exportInfo');
                    if (!infoElement) return;
                    
                    let content = '';
                    
                    if (state.selectedPolicyArea) {
                        content += `<div><strong>Policy Area:</strong> ${utils.escapeHtml(state.selectedPolicyArea)}</div>`;
                    }
                    if (state.selectedPhase) {
                        content += `<div><strong>Phase:</strong> ${utils.escapeHtml(state.selectedPhase)}</div>`;
                    }
                    if (state.selectedPolicy) {
                        content += `<div><strong>Initiative Overview:</strong> ${utils.escapeHtml(state.selectedPolicy)}</div>`;
                        const policyKey = utils.getPolicyKey(state.selectedPolicyArea, state.selectedPhase, state.selectedPolicy);
                        const isSelected = state.selectedPolicies.has(policyKey);
                        content += `<div class="status-badge ${isSelected ? 'status-selected' : 'status-viewing'}" style="background: ${isSelected ? 'var(--color-green-100)' : '#fef3c7'}; color: ${isSelected ? 'var(--color-green-700)' : '#92400e'}; display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; margin-top: 0.5rem;">
                            ${isSelected ? 'Selected' : 'Viewing'}
                        </div>`;
                    }
                    
                    // Show active filters if no dimension/phase selected
                    if (!state.selectedPolicyArea && !state.selectedPhase) {
                        if (state.searchTerm || state.activeKeywords.size > 0) {
                            content = '<div><strong>Active Filters:</strong></div>';
                            if (state.searchTerm) {
                                content += `<div>Search: "${utils.escapeHtml(state.searchTerm)}"</div>`;
                            }
                            if (state.activeKeywords.size > 0) {
                                const keywords = Array.from(state.activeKeywords).join(', ');
                                content += `<div>Keywords: ${utils.escapeHtml(keywords)}</div>`;
                            }
                        } else {
                            content = 'Select a dimension or use search/filters to begin';
                        }
                    } else if (!content) {
                        content = 'Select a dimension to begin';
                    }
                    
                    infoElement.innerHTML = content;

                    // Update export info
                    if (exportInfoElement) {
                        const selectedCount = state.selectedPolicies.size;
                        if (selectedCount === 0) {
                            exportInfoElement.textContent = 'Select policies to generate your implementation report';
                        } else {
                            exportInfoElement.textContent = `Ready to export report with ${selectedCount} selected policy${selectedCount === 1 ? '' : 'ies'} (PDF online, text locally)`;
                        }
                    }

                    // Update selected policies section
                    this.updateSelectedPoliciesSection();
                },
                // ADD THE NEW METHOD HERE:
                togglePolicyListVisibility: function() {
                    const policyContainer = document.getElementById('policyContainer');
                    const policyDetailsColumn = document.getElementById('policyDetailsColumn');
                    
                    if (policyContainer && policyDetailsColumn) {
                        const isFocused = policyContainer.classList.contains('details-focused');
                        
                        if (isFocused) {
                            // Show the list
                            policyContainer.classList.remove('details-focused');
                            policyDetailsColumn.classList.remove('has-policy');
                        } else {
                            // Hide the list (focus on details)
                            policyContainer.classList.add('details-focused');
                            if (state.selectedPolicy) {
                                policyDetailsColumn.classList.add('has-policy');
                            }
                        }
                    }
                }
            };
            

            function getRelevantExpertsForPolicies(selectedPolicies) {
                // Collect all keywords from selected policies
                const allKeywords = new Set();
                
                Array.from(selectedPolicies).forEach(policyKey => {
                    const [dimension, phase, policyId] = policyKey.split('|');
                    const policyInfo = policyData[dimension]?.[phase]?.[policyId];
                    if (policyInfo && Array.isArray(policyInfo.keywords)) {
                        policyInfo.keywords.forEach(keyword => allKeywords.add(keyword));
                    }
                });
                
                // Find experts matching these keywords
                const policyKeywords = Array.from(allKeywords);
                const relevantExperts = findRelevantExperts(policyKeywords, 3); // Get top 3
                
                return relevantExperts;
            }
            window.exportToPDF = async function() {
                if (state.selectedPolicies.size === 0) {
                    alert('Please select at least one policy initiative before exporting.');
                    return;
                }

                // Design system for professional policy documents
                const DESIGN = {
                    colors: {
                        // TPAF dimension colors
                        infrastructure: '#005193',
                        legislation: '#FBAD17', 
                        sustainability: '#9C27B0',
                        economic: '#E11A2C',
                        education: '#4CAF50',
                        
                        // Document colors
                        primary: '#1a365d',
                        secondary: '#2d3748',
                        text: '#2d3748',
                        textLight: '#4a5568',
                        textMuted: '#718096',
                        background: '#ffffff',
                        backgroundLight: '#f8fafc',
                        border: '#e2e8f0',
                        accent: '#3182ce'
                    },
                    
                    typography: {
                        title: 18,
                        sectionTitle: 14,
                        heading: 11,
                        subheading: 9,
                        body: 9,
                        small: 8,
                        tiny: 7
                    },
                    
                    spacing: {
                        margin: 20,
                        section: 12,
                        policy: 8,
                        paragraph: 4,
                        element: 3
                    },
                    
                    layout: {
                        lineHeight: 1.4,
                        paragraphSpacing: 4,
                        maxTextWidth: 170
                    }
                };

                // Helper: Convert hex to RGB
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result 
                        ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)]
                        : [0, 0, 0];
                };

                // Helper: Get dimension color
                const getPolicyAreaColor = (dimension) => {
                    const colorMap = {
                        'Enabling Infrastructure': DESIGN.colors.infrastructure,
                        'Legislation and Policy': DESIGN.colors.legislation,
                        'Sustainability and Society': DESIGN.colors.sustainability,
                        'Economy & Innovation': DESIGN.colors.economic,
                        'Research & Education': DESIGN.colors.education
                    };
                    return colorMap[dimension] || DESIGN.colors.primary;
                };

                // Helper: Render paragraph with proper spacing
                const renderParagraph = (pdf, text, x, y, maxWidth, pageWidth, fontSize = DESIGN.typography.body, lineHeight = DESIGN.layout.lineHeight) => {
                    if (!text || text.trim() === '') return 0;

                    pdf.setFont('helvetica', 'normal');
                    pdf.setFontSize(fontSize);
                    
                    const actualMaxWidth = Math.min(maxWidth, pageWidth - x - DESIGN.spacing.margin);
                    const lines = pdf.splitTextToSize(text.trim(), actualMaxWidth);
                    const lineHeightInMM = (fontSize * lineHeight) / 2.83465;
                    
                    lines.forEach((line, index) => {
                        pdf.text(line, x, y + (index * lineHeightInMM));
                    });
                    
                    return lines.length * lineHeightInMM;
                };

                // Helper: Draw section header
                const drawSectionHeader = (pdf, title, subtitle, color, x, y, width, percentage) => {
                    const headerHeight = 25;
                    
                    pdf.setFillColor(...hexToRgb(color));
                    pdf.rect(x, y, width, headerHeight, 'F');
                    
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setFontSize(DESIGN.typography.sectionTitle);
                    
                    const titleWidth = pdf.getStringUnitWidth(title) * DESIGN.typography.sectionTitle / pdf.internal.scaleFactor;
                    const maxTitleWidth = width - (percentage ? 40 : 16);
                    
                    let displayTitle = title;
                    if (titleWidth > maxTitleWidth) {
                        while (pdf.getStringUnitWidth(displayTitle + '...') * DESIGN.typography.sectionTitle / pdf.internal.scaleFactor > maxTitleWidth && displayTitle.length > 0) {
                            displayTitle = displayTitle.slice(0, -1);
                        }
                        displayTitle += '...';
                    }
                    
                    pdf.text(displayTitle, x + 8, y + 12);
                    
                    pdf.setFont('helvetica', 'normal');
                    pdf.setFontSize(DESIGN.typography.small);
                    pdf.text(subtitle, x + 8, y + 20);
                    
                    if (percentage !== undefined) {
                        pdf.setFont('helvetica', 'bold');
                        pdf.setFontSize(12);
                        // pdf.text(`${percentage}% completed`, x + width - 4, y + 5, { align: 'right' });
                    }
                    
                    return headerHeight;
                };

                // Capture matrix visualization
                const captureMatrixVisualization = async () => {
                    try {
                        const html2canvas = (await import('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.esm.min.js')).default;
                        
                        const matrixContainer = document.querySelector('.selection-matrix-container');
                        if (!matrixContainer) return null;

                        const canvas = await html2canvas(matrixContainer, {
                            backgroundColor: 'white',
                            scale: 2,
                            logging: false,
                            useCORS: true
                        });

                        return canvas.toDataURL('image/png', 0.95);
                    } catch (error) {
                        console.error('Implementation Plan Dashboard capture failed:', error);
                        return null;
                    }
                };

                try {
                    // Check if jsPDF is available
                    let jsPDF;
                    if (window.jspdf && window.jspdf.jsPDF) {
                        jsPDF = window.jspdf.jsPDF;
                    } else if (window.jsPDF) {
                        jsPDF = window.jsPDF;
                    } else {
                        alert('PDF library not loaded. Please refresh the page and try again.');
                        return;
                    }

                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4',
                        compress: true
                    });

                    pdf.setProperties({
                        subject: 'Selected Policy Options for Implementation',
                        keywords: 'AI governance, policy implementation, TPAF, G20, policy options',
                        creator: 'G20 TPAF Platform'
                    });

                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const margin = DESIGN.spacing.margin;
                    const contentWidth = pageWidth - (margin * 2);
                    let currentY = margin;

                    // Calculate statistics
                    const savedCount = state.selectedPolicies.size;
                    
                    // Group policies by dimension
                    const policiesByPolicyArea = {};
                    Array.from(state.selectedPolicies).forEach(policyKey => {
                        const [dimension, phase, policyId] = policyKey.split('|');
                        if (!policiesByPolicyArea[dimension]) {
                            policiesByPolicyArea[dimension] = [];
                        }
                        
                        const policyInfo = policyData[dimension]?.[phase]?.[policyId];
                        if (policyInfo) {
                            policiesByPolicyArea[dimension].push({
                                id: policyId,
                                phase: phase,
                                policy: policyInfo.policy,
                                details: policyInfo.details,
                                examples: policyInfo.examples,
                                keywords: policyInfo.keywords
                            });
                        }
                    });

                    // ==================== COVER PAGE ====================
                    pdf.setFillColor(...hexToRgb(DESIGN.colors.primary));
                    pdf.rect(0, 0, pageWidth, pageHeight, 'F');

                    // G20 Logo area
                    pdf.setFillColor(255, 255, 255);
                    pdf.rect(margin, 15, 60, 15, 'F');
                    pdf.setTextColor(...hexToRgb(DESIGN.colors.primary));
                    pdf.setFont('helvetica', 'bold');
                    pdf.setFontSize(14);
                    pdf.text('G20 TPAF', margin + 30, 25, { align: 'center' });

                    // Main title
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setFontSize(24);
                    pdf.text('Implementation Plan: Selected Policy Initiatives', pageWidth/2, 87, { align: 'center' });
                    // Subtitle
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'normal');
                    const today = new Date().toLocaleDateString('en-US', { 
                        year: 'numeric', month: 'long', day: 'numeric' 
                    });
                    pdf.text(`Generated: ${today}`, pageWidth/2, 120, { align: 'center' });
                    pdf.text(`Selected Policy Initiatives: ${savedCount}`, pageWidth/2, 135, { align: 'center' });

                    const dimensionCount = Object.keys(policiesByPolicyArea).length;
                    pdf.text(`Covering ${dimensionCount} policy areas`, pageWidth/2, 150, { align: 'center' });

                    // Summary information at bottom
                    const summaryBoxY = pageHeight - 80;
                    pdf.setFontSize(DESIGN.typography.body);
                    const summaryTextY = summaryBoxY + 15;
                    pdf.text('G20 Technology Policy Assistance Facility (TPAF)', pageWidth / 2, summaryTextY, { align: 'center' });
                    pdf.text('Selected Policy Initiatives', pageWidth / 2, summaryTextY + 10, { align: 'center' });

                    // ==================== EXECUTIVE SUMMARY ====================
                    pdf.addPage();
                    currentY = margin;

                    pdf.setTextColor(...hexToRgb(DESIGN.colors.primary));
                    pdf.setFont('helvetica', 'bold');
                    pdf.setFontSize(DESIGN.typography.sectionTitle);
                    pdf.text('Executive Summary', margin, currentY);
                    currentY += 15;

                    pdf.setTextColor(...hexToRgb(DESIGN.colors.text));
                    pdf.setFont('helvetica', 'normal');
                    pdf.setFontSize(DESIGN.typography.body);
                    
                    const overviewText = `This implementation plan outlines ${savedCount} selected AI policy inititatives across ${dimensionCount} key policy areas.`;
                    
                    currentY += renderParagraph(pdf, overviewText, margin, currentY, contentWidth, pageWidth, DESIGN.typography.body);
                    currentY += DESIGN.spacing.paragraph;

                    // PolicyArea Overview
                    pdf.setFont('helvetica', 'bold');
                    pdf.setFontSize(DESIGN.typography.heading);
                    pdf.text('Selected Policy Areas', margin, currentY);
                    currentY += 8;

                    pdf.setFont('helvetica', 'normal');
                    pdf.setFontSize(DESIGN.typography.body);

                    Object.entries(policiesByPolicyArea).forEach(([dimension, policies]) => {
                        if (currentY > pageHeight - 40) {
                            pdf.addPage();
                            currentY = margin;
                        }

                        const dimColor = getPolicyAreaColor(dimension);
                        
                        pdf.setFillColor(...hexToRgb(dimColor));
                        pdf.rect(margin, currentY - 2, 3, 6, 'F');
                        
                        pdf.setTextColor(...hexToRgb(DESIGN.colors.text));
                        pdf.setFont('helvetica', 'bold');
                        pdf.text(`${dimension}:`, margin + 6, currentY);
                        
                        pdf.setFont('helvetica', 'normal');
                        const uniquePhases = [...new Set(policies.map(p => p.phase))];
                        const summaryText = `${policies.length} policy options selected, covering ${uniquePhases.length} implementation phases`;
                        currentY += renderParagraph(pdf, summaryText, margin + 6, currentY + 4, contentWidth - 6, pageWidth, DESIGN.typography.small);
                        currentY += 8;
                    });

                    if (expertsData.length > 0) {
                        const relevantExperts = getRelevantExpertsForPolicies(state.selectedPolicies);
                        
                        if (relevantExperts.length > 0) {
                            // Check if we need a new page
                            if (currentY > pageHeight - 30) {
                                pdf.addPage();
                                currentY = margin;
                            }
                            
                            // Add some spacing from previous section
                            currentY += 8;
                            
                            pdf.setTextColor(...hexToRgb(DESIGN.colors.text));
                            pdf.setFont('helvetica', 'normal');
                            pdf.setFontSize(DESIGN.typography.body);
                            
                            const expertNames = relevantExperts.map(expert => expert.name).join(', ');
                            const expertsText = `Relevant experts working in similar policy areas: ${expertNames}`;
                            
                            currentY += renderParagraph(pdf, expertsText, margin, currentY, contentWidth, pageWidth, DESIGN.typography.body);
                            currentY += DESIGN.spacing.paragraph;
                        }
                    }



                    // ==================== MATRIX VISUALIZATION ====================
                    const matrixImageData = await captureMatrixVisualization();
                    if (matrixImageData) {
                        pdf.addPage();
                        currentY = margin;

                        pdf.setTextColor(...hexToRgb(DESIGN.colors.primary));
                        pdf.setFont('helvetica', 'bold');
                        pdf.setFontSize(DESIGN.typography.sectionTitle);
                        pdf.text('Implementation Plan Dashboard', margin, currentY);
                        currentY += 15;

                        const imgWidth = contentWidth;
                        const imgHeight = Math.min(224, imgWidth * 0.84);
                        
                        pdf.addImage(matrixImageData, 'PNG', margin, currentY, imgWidth, imgHeight);
                        currentY += imgHeight + 10;
                        
                        pdf.setFont('helvetica', 'normal');
                        pdf.setFontSize(DESIGN.typography.small);
                        pdf.setTextColor(...hexToRgb(DESIGN.colors.textMuted));
                        const captionText = 'This matrix shows your selected policy initiatives (represented by colored bars) across the five policy areas and four implementation phases.';
                        renderParagraph(pdf, captionText, margin, currentY, contentWidth, pageWidth, DESIGN.typography.small);
                    }

                    // ==================== DETAILED POLICY SECTIONS ====================
                    Object.entries(policiesByPolicyArea).forEach(([dimension, policies]) => {
                        pdf.addPage();
                        currentY = margin;

                        const dimColor = getPolicyAreaColor(dimension);
                        
                        // Calculate total policies in this dimension for percentage
                        const totalInPolicyArea = Object.values(policyData[dimension] || {})
                            .reduce((total, phaseData) => total + Object.keys(phaseData).length, 0);
                        const percentageSelected = Math.round((policies.length / totalInPolicyArea) * 100);

                        const headerHeight = drawSectionHeader(
                            pdf, 
                            dimension, 
                            `${policies.length} selected policy options`,
                            dimColor,
                            margin,
                            currentY,
                            contentWidth,
                            percentageSelected
                        );
                        currentY += headerHeight + DESIGN.spacing.section;

                        // Individual Policy Sections
                        policies.forEach((policy, policyIndex) => {
                            const estimatedPolicyHeight = 100;
                            if (currentY > pageHeight - estimatedPolicyHeight && policyIndex > 0) {
                                pdf.addPage();
                                currentY = margin;
                            }

                                // ADD RELEVANT EXPERTS PER POLICY:
                            if (expertsData.length > 0 && policy.keywords && policy.keywords.length > 0) {
                                const relevantExperts = findRelevantExperts(policy.keywords, 3);
                                
                                if (relevantExperts.length > 0) {
                                    if (currentY > pageHeight - 15) {
                                        pdf.addPage();
                                        currentY = margin;
                                    }
                                    
                                    pdf.setFont('helvetica', 'bold');
                                    pdf.setFontSize(DESIGN.typography.small);
                                    pdf.setTextColor(...hexToRgb(DESIGN.colors.textMuted));
                                    pdf.text('Relevant experts: ', margin, currentY);
                                    
                                    pdf.setFont('helvetica', 'normal');
                                    const expertNames = relevantExperts.map(expert => expert.name).join(', ');
                                    const expertsHeight = renderParagraph(pdf, expertNames, margin + 28, currentY, contentWidth - 28, pageWidth, DESIGN.typography.small);
                                    currentY += Math.max(8, expertsHeight);
                                }
                            }

                            // Policy header
                            const headerWidth = contentWidth;
                            pdf.setFillColor(...hexToRgb(DESIGN.colors.backgroundLight));
                            pdf.rect(margin, currentY, headerWidth, 12, 'F');
                            
                            pdf.setFillColor(...hexToRgb(dimColor));
                            pdf.rect(margin, currentY, 4, 12, 'F');

                            pdf.setTextColor(...hexToRgb(DESIGN.colors.text));
                            pdf.setFont('helvetica', 'bold');
                            pdf.setFontSize(DESIGN.typography.heading);
                            
                            const titleText = `${policyIndex + 1}. ${policy.id}: ${policy.policy}`;
                            const titleHeight = renderParagraph(pdf, titleText, margin + 8, currentY + 8, headerWidth - 16, pageWidth, DESIGN.typography.heading);
                            
                            const actualHeaderHeight = Math.max(12, titleHeight + 4);
                            if (actualHeaderHeight > 12) {
                                pdf.setFillColor(...hexToRgb(DESIGN.colors.backgroundLight));
                                pdf.rect(margin, currentY, headerWidth, actualHeaderHeight, 'F');
                                pdf.setFillColor(...hexToRgb(dimColor));
                                pdf.rect(margin, currentY, 4, actualHeaderHeight, 'F');
                                pdf.setTextColor(...hexToRgb(DESIGN.colors.text));
                                pdf.setFont('helvetica', 'bold');
                                pdf.setFontSize(DESIGN.typography.heading);
                                renderParagraph(pdf, titleText, margin + 8, currentY + 8, headerWidth - 16, pageWidth, DESIGN.typography.heading);
                            }
                            
                            currentY += actualHeaderHeight + 3;

                            // Implementation phase
                            pdf.setFont('helvetica', 'normal');
                            pdf.setFontSize(DESIGN.typography.small);
                            pdf.setTextColor(...hexToRgb(DESIGN.colors.textMuted));
                            pdf.text(`Implementation Phase: ${policy.phase}`, margin, currentY);
                            currentY += 8;

                            // Policy details
                            if (policy.details && policy.details.trim()) {
                                pdf.setTextColor(...hexToRgb(DESIGN.colors.text));
                                pdf.setFont('helvetica', 'bold');
                                pdf.setFontSize(DESIGN.typography.subheading);
                                pdf.text('Implementation Details:', margin, currentY);
                                currentY += 6;
                                
                                pdf.setFont('helvetica', 'normal');
                                pdf.setFontSize(DESIGN.typography.body);
                                const detailsHeight = renderParagraph(pdf, policy.details, margin, currentY, contentWidth, pageWidth, DESIGN.typography.body);
                                currentY += detailsHeight + DESIGN.spacing.paragraph;
                            }

                            // Examples
                            if (policy.examples && policy.examples.trim()) {
                                if (currentY > pageHeight - 40) {
                                    pdf.addPage();
                                    currentY = margin;
                                }

                                pdf.setFont('helvetica', 'bold');
                                pdf.setFontSize(DESIGN.typography.subheading);
                                pdf.text('Implementation Examples:', margin, currentY);
                                currentY += 6;
                                
                                pdf.setFont('helvetica', 'normal');
                                pdf.setFontSize(DESIGN.typography.body);
                                const examplesHeight = renderParagraph(pdf, policy.examples, margin, currentY, contentWidth, pageWidth, DESIGN.typography.body);
                                currentY += examplesHeight + DESIGN.spacing.paragraph;
                            }

                            // Keywords
                            if (policy.keywords && policy.keywords.length > 0) {
                                if (currentY > pageHeight - 15) {
                                    pdf.addPage();
                                    currentY = margin;
                                }
                                
                                pdf.setFont('helvetica', 'bold');
                                pdf.setFontSize(DESIGN.typography.small);
                                pdf.setTextColor(...hexToRgb(DESIGN.colors.textMuted));
                                pdf.text('Keywords: ', margin, currentY);
                                
                                pdf.setFont('helvetica', 'normal');
                                const keywordText = Array.isArray(policy.keywords) ? policy.keywords.join(', ') : policy.keywords;
                                const keywordsHeight = renderParagraph(pdf, keywordText, margin + 20, currentY, contentWidth - 20, pageWidth, DESIGN.typography.small);
                                currentY += Math.max(8, keywordsHeight);
                            }

                            currentY += DESIGN.spacing.policy;
                        });
                    });

                    // ==================== FOOTER SYSTEM ====================
                    const totalPages = pdf.internal.pages.length - 1;
                    
                    for (let i = 1; i <= totalPages; i++) {
                        pdf.setPage(i);
                        
                        if (i === 1) continue; // Skip cover
                        
                        pdf.setDrawColor(...hexToRgb(DESIGN.colors.border));
                        pdf.setLineWidth(0.3);
                        pdf.line(margin, pageHeight - 12, pageWidth - margin, pageHeight - 12);
                        
                        pdf.setTextColor(...hexToRgb(DESIGN.colors.textMuted));
                        pdf.setFontSize(DESIGN.typography.tiny);
                        
                        pdf.text('G20 TPAF Implementation Plan', margin, pageHeight - 7);
                        pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, pageHeight - 7, { align: 'right' });
                    }

                    // ==================== SAVE PDF ====================
                    const timestamp = new Date().toISOString().split('T')[0];
                    const filename = `G20_TPAF_Implementation_Plan_${timestamp}.pdf`;
                    
                    pdf.save(filename);
                    console.log(`Implementation plan generated: ${filename}`);
                    
                } catch (error) {
                    console.error('PDF Export Error:', error);
                    alert(`Export failed: ${error.message}. Please try refreshing the page.`);
                }
            };
            // Initialize the application
            async function initializeApp() {
                try {
                    // Show loading state
                    document.body.classList.add('loading');
                    
                    // Load both data sources
                    const [policyLoaded, expertsLoaded] = await Promise.all([
                        loadPolicyData(),
                        loadExpertsData()
                    ]);

                    if (!policyLoaded) {
                        return; // Error already handled in loadPolicyData
                    }

                    // Initialize the main application
                    app.init();
                    
                    // Initialize experts display
                    if (expertsLoaded) {
                        updateRelevantExperts();
                    }

                    // Remove loading state
                    document.body.classList.remove('loading');
                    
                    // Event listener for button system integration
                    document.addEventListener('tpafSelectionChange', (e) => {
                        console.log('Selection changed:', e.detail);
                    });
                    
                    console.log('Application initialized successfully');
                    
                } catch (error) {
                    console.error('Failed to initialize application:', error);
                    document.body.innerHTML = `
                        <div style="padding: 2rem; text-align: center;">
                            <div class="error-message">
                                Failed to initialize application. Please refresh the page and try again.
                            </div>
                        </div>
                    `;
                }
            }

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeApp);
            } else {
                initializeApp();
            }

            // Development debugging (only in localhost)
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                window.AIPolicy = {
                    getState: () => ({ ...state }),
                    getSelectedPolicies: () => Array.from(state.selectedPolicies),
                    buttonSystem: buttonSystem
                };
            }
        })();
    </script>
</body>
</html>